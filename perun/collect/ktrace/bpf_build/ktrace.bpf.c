/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
   This file is automatically generated! */

#include "vmlinux.h"
#include <bpf/bpf_tracing.h>
#include "ktrace.h"

char LICENSE[] SEC("license") = "Dual BSD/GPL";

struct {
	__uint(type, BPF_MAP_TYPE_RINGBUF);
	__uint(max_entries, 16777216);
} rb SEC(".maps");

uint64_t events_lost = 0;
pid_t process_pid = 0;

SEC("tp/sched/sched_process_exec")
int handle_exec(struct trace_event_raw_sched_process_exec *ctx)
{
	char comm[14];
	bpf_get_current_comm(comm, 14);
	if (bpf_strncmp(comm, 13, "mmap_mprotect" ) == 0) {
		process_pid = bpf_get_current_pid_tgid() >> 32;
		bpf_printk("EXEC mmap_mprotect: pid = %d\n", process_pid);
	}
	return 0;
}

SEC("tp/sched/sched_process_exit")
int handle_exit(struct trace_event_raw_sched_process_template *ctx)
{
	if ((bpf_get_current_pid_tgid() >> 32) == process_pid) {
		bpf_printk("EXIT mmap_mprotect: pid = %d\n", process_pid);
		process_pid = 0;
	}
	return 0;
}


SEC("kprobe/___pte_free_tlb")
int BPF_KPROBE(___pte_free_tlb)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (0 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/___pte_free_tlb")
int BPF_KRETPROBE(___pte_free_tlb_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (0 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/___slab_alloc")
int BPF_KPROBE(___slab_alloc)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (1 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/___slab_alloc")
int BPF_KRETPROBE(___slab_alloc_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (1 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__alloc_pages")
int BPF_KPROBE(__alloc_pages)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (2 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__alloc_pages")
int BPF_KRETPROBE(__alloc_pages_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (2 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__anon_vma_interval_tree_augment_rotate")
int BPF_KPROBE(__anon_vma_interval_tree_augment_rotate)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (3 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__anon_vma_interval_tree_augment_rotate")
int BPF_KRETPROBE(__anon_vma_interval_tree_augment_rotate_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (3 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__cgroup_throttle_swaprate")
int BPF_KPROBE(__cgroup_throttle_swaprate)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (4 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__cgroup_throttle_swaprate")
int BPF_KRETPROBE(__cgroup_throttle_swaprate_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (4 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__cond_resched")
int BPF_KPROBE(__cond_resched)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (5 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__cond_resched")
int BPF_KRETPROBE(__cond_resched_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (5 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__count_memcg_events")
int BPF_KPROBE(__count_memcg_events)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (6 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__count_memcg_events")
int BPF_KRETPROBE(__count_memcg_events_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (6 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__handle_mm_fault")
int BPF_KPROBE(__handle_mm_fault)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (7 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__handle_mm_fault")
int BPF_KRETPROBE(__handle_mm_fault_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (7 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__mem_cgroup_charge")
int BPF_KPROBE(__mem_cgroup_charge)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (8 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__mem_cgroup_charge")
int BPF_KRETPROBE(__mem_cgroup_charge_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (8 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__mod_lruvec_page_state")
int BPF_KPROBE(__mod_lruvec_page_state)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (9 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__mod_lruvec_page_state")
int BPF_KRETPROBE(__mod_lruvec_page_state_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (9 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__mod_lruvec_state")
int BPF_KPROBE(__mod_lruvec_state)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (10 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__mod_lruvec_state")
int BPF_KRETPROBE(__mod_lruvec_state_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (10 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__mod_memcg_lruvec_state")
int BPF_KPROBE(__mod_memcg_lruvec_state)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (11 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__mod_memcg_lruvec_state")
int BPF_KRETPROBE(__mod_memcg_lruvec_state_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (11 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__mod_node_page_state")
int BPF_KPROBE(__mod_node_page_state)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (12 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__mod_node_page_state")
int BPF_KRETPROBE(__mod_node_page_state_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (12 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__mod_zone_page_state")
int BPF_KPROBE(__mod_zone_page_state)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (13 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__mod_zone_page_state")
int BPF_KRETPROBE(__mod_zone_page_state_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (13 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__next_zones_zonelist")
int BPF_KPROBE(__next_zones_zonelist)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (14 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__next_zones_zonelist")
int BPF_KRETPROBE(__next_zones_zonelist_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (14 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__page_set_anon_rmap")
int BPF_KPROBE(__page_set_anon_rmap)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (15 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__page_set_anon_rmap")
int BPF_KRETPROBE(__page_set_anon_rmap_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (15 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__pagevec_lru_add")
int BPF_KPROBE(__pagevec_lru_add)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (16 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__pagevec_lru_add")
int BPF_KRETPROBE(__pagevec_lru_add_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (16 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__slab_free")
int BPF_KPROBE(__slab_free)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (17 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__slab_free")
int BPF_KRETPROBE(__slab_free_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (17 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__tlb_remove_page_size")
int BPF_KPROBE(__tlb_remove_page_size)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (18 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__tlb_remove_page_size")
int BPF_KRETPROBE(__tlb_remove_page_size_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (18 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__unfreeze_partials")
int BPF_KPROBE(__unfreeze_partials)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (19 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__unfreeze_partials")
int BPF_KRETPROBE(__unfreeze_partials_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (19 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__vma_adjust")
int BPF_KPROBE(__vma_adjust)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (20 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__vma_adjust")
int BPF_KRETPROBE(__vma_adjust_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (20 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/__x64_sys_mprotect")
int BPF_KPROBE(__x64_sys_mprotect)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (21 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/__x64_sys_mprotect")
int BPF_KRETPROBE(__x64_sys_mprotect_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (21 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/_raw_spin_lock")
int BPF_KPROBE(_raw_spin_lock)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (22 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/_raw_spin_lock")
int BPF_KRETPROBE(_raw_spin_lock_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (22 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/_raw_spin_unlock")
int BPF_KPROBE(_raw_spin_unlock)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (23 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/_raw_spin_unlock")
int BPF_KRETPROBE(_raw_spin_unlock_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (23 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/acct_collect")
int BPF_KPROBE(acct_collect)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (24 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/acct_collect")
int BPF_KRETPROBE(acct_collect_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (24 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/add_mm_counter_fast")
int BPF_KPROBE(add_mm_counter_fast)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (25 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/add_mm_counter_fast")
int BPF_KRETPROBE(add_mm_counter_fast_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (25 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/alloc_pages_vma")
int BPF_KPROBE(alloc_pages_vma)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (26 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/alloc_pages_vma")
int BPF_KRETPROBE(alloc_pages_vma_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (26 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/anon_vma_interval_tree_insert")
int BPF_KPROBE(anon_vma_interval_tree_insert)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (27 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/anon_vma_interval_tree_insert")
int BPF_KRETPROBE(anon_vma_interval_tree_insert_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (27 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/bad_range")
int BPF_KPROBE(bad_range)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (28 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/bad_range")
int BPF_KRETPROBE(bad_range_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (28 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/cgroup_rstat_updated")
int BPF_KPROBE(cgroup_rstat_updated)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (29 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/cgroup_rstat_updated")
int BPF_KRETPROBE(cgroup_rstat_updated_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (29 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/change_protection")
int BPF_KPROBE(change_protection)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (30 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/change_protection")
int BPF_KRETPROBE(change_protection_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (30 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/charge_memcg")
int BPF_KPROBE(charge_memcg)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (31 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/charge_memcg")
int BPF_KRETPROBE(charge_memcg_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (31 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/cpuset_nodemask_valid_mems_allowed")
int BPF_KPROBE(cpuset_nodemask_valid_mems_allowed)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (32 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/cpuset_nodemask_valid_mems_allowed")
int BPF_KRETPROBE(cpuset_nodemask_valid_mems_allowed_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (32 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/down_read_trylock")
int BPF_KPROBE(down_read_trylock)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (33 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/down_read_trylock")
int BPF_KRETPROBE(down_read_trylock_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (33 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/down_write")
int BPF_KPROBE(down_write)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (34 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/down_write")
int BPF_KRETPROBE(down_write_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (34 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/find_vma")
int BPF_KPROBE(find_vma)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (35 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/find_vma")
int BPF_KRETPROBE(find_vma_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (35 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/flush_tlb_batched_pending")
int BPF_KPROBE(flush_tlb_batched_pending)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (36 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/flush_tlb_batched_pending")
int BPF_KRETPROBE(flush_tlb_batched_pending_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (36 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/flush_tlb_func")
int BPF_KPROBE(flush_tlb_func)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (37 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/flush_tlb_func")
int BPF_KRETPROBE(flush_tlb_func_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (37 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/folio_add_lru")
int BPF_KPROBE(folio_add_lru)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (38 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/folio_add_lru")
int BPF_KRETPROBE(folio_add_lru_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (38 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/folio_lruvec_lock_irqsave")
int BPF_KPROBE(folio_lruvec_lock_irqsave)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (39 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/folio_lruvec_lock_irqsave")
int BPF_KRETPROBE(folio_lruvec_lock_irqsave_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (39 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/folio_mapping")
int BPF_KPROBE(folio_mapping)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (40 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/folio_mapping")
int BPF_KRETPROBE(folio_mapping_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (40 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/free_pcppages_bulk")
int BPF_KPROBE(free_pcppages_bulk)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (41 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/free_pcppages_bulk")
int BPF_KRETPROBE(free_pcppages_bulk_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (41 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/free_pgtables")
int BPF_KPROBE(free_pgtables)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (42 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/free_pgtables")
int BPF_KRETPROBE(free_pgtables_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (42 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/free_swap_cache")
int BPF_KPROBE(free_swap_cache)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (43 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/free_swap_cache")
int BPF_KRETPROBE(free_swap_cache_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (43 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/free_unref_page_commit.constprop.0")
int BPF_KPROBE(free_unref_page_commit_constprop_0)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (44 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/free_unref_page_commit.constprop.0")
int BPF_KRETPROBE(free_unref_page_commit_constprop_0_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (44 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/free_unref_page_list")
int BPF_KPROBE(free_unref_page_list)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (45 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/free_unref_page_list")
int BPF_KRETPROBE(free_unref_page_list_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (45 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/get_mem_cgroup_from_mm")
int BPF_KPROBE(get_mem_cgroup_from_mm)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (46 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/get_mem_cgroup_from_mm")
int BPF_KRETPROBE(get_mem_cgroup_from_mm_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (46 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/get_page_from_freelist")
int BPF_KPROBE(get_page_from_freelist)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (47 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/get_page_from_freelist")
int BPF_KRETPROBE(get_page_from_freelist_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (47 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/handle_mm_fault")
int BPF_KPROBE(handle_mm_fault)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (48 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/handle_mm_fault")
int BPF_KRETPROBE(handle_mm_fault_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (48 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/ima_file_mprotect")
int BPF_KPROBE(ima_file_mprotect)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (49 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/ima_file_mprotect")
int BPF_KRETPROBE(ima_file_mprotect_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (49 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/kmem_cache_alloc")
int BPF_KPROBE(kmem_cache_alloc)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (50 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/kmem_cache_alloc")
int BPF_KRETPROBE(kmem_cache_alloc_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (50 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/kthread_blkcg")
int BPF_KPROBE(kthread_blkcg)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (51 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/kthread_blkcg")
int BPF_KRETPROBE(kthread_blkcg_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (51 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/lock_page_memcg")
int BPF_KPROBE(lock_page_memcg)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (52 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/lock_page_memcg")
int BPF_KRETPROBE(lock_page_memcg_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (52 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/lru_cache_add")
int BPF_KPROBE(lru_cache_add)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (53 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/lru_cache_add")
int BPF_KRETPROBE(lru_cache_add_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (53 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/lru_cache_add_inactive_or_unevictable")
int BPF_KPROBE(lru_cache_add_inactive_or_unevictable)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (54 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/lru_cache_add_inactive_or_unevictable")
int BPF_KRETPROBE(lru_cache_add_inactive_or_unevictable_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (54 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/mem_cgroup_charge_statistics")
int BPF_KPROBE(mem_cgroup_charge_statistics)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (55 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/mem_cgroup_charge_statistics")
int BPF_KRETPROBE(mem_cgroup_charge_statistics_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (55 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/mem_cgroup_from_task")
int BPF_KPROBE(mem_cgroup_from_task)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (56 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/mem_cgroup_from_task")
int BPF_KRETPROBE(mem_cgroup_from_task_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (56 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/mem_cgroup_update_lru_size")
int BPF_KPROBE(mem_cgroup_update_lru_size)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (57 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/mem_cgroup_update_lru_size")
int BPF_KRETPROBE(mem_cgroup_update_lru_size_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (57 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/memcg_check_events")
int BPF_KPROBE(memcg_check_events)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (58 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/memcg_check_events")
int BPF_KRETPROBE(memcg_check_events_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (58 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/mod_objcg_state")
int BPF_KPROBE(mod_objcg_state)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (59 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/mod_objcg_state")
int BPF_KRETPROBE(mod_objcg_state_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (59 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/native_flush_tlb_one_user")
int BPF_KPROBE(native_flush_tlb_one_user)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (60 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/native_flush_tlb_one_user")
int BPF_KRETPROBE(native_flush_tlb_one_user_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (60 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/obj_cgroup_charge")
int BPF_KPROBE(obj_cgroup_charge)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (61 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/obj_cgroup_charge")
int BPF_KRETPROBE(obj_cgroup_charge_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (61 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/page_add_new_anon_rmap")
int BPF_KPROBE(page_add_new_anon_rmap)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (62 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/page_add_new_anon_rmap")
int BPF_KRETPROBE(page_add_new_anon_rmap_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (62 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/page_counter_try_charge")
int BPF_KPROBE(page_counter_try_charge)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (63 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/page_counter_try_charge")
int BPF_KRETPROBE(page_counter_try_charge_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (63 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/page_remove_rmap")
int BPF_KPROBE(page_remove_rmap)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (64 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/page_remove_rmap")
int BPF_KRETPROBE(page_remove_rmap_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (64 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/pmd_install")
int BPF_KPROBE(pmd_install)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (65 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/pmd_install")
int BPF_KRETPROBE(pmd_install_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (65 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/policy_node")
int BPF_KPROBE(policy_node)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (66 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/policy_node")
int BPF_KRETPROBE(policy_node_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (66 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/policy_nodemask")
int BPF_KPROBE(policy_nodemask)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (67 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/policy_nodemask")
int BPF_KRETPROBE(policy_nodemask_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (67 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/rcu_sched_clock_irq")
int BPF_KPROBE(rcu_sched_clock_irq)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (68 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/rcu_sched_clock_irq")
int BPF_KRETPROBE(rcu_sched_clock_irq_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (68 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/release_pages")
int BPF_KPROBE(release_pages)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (69 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/release_pages")
int BPF_KRETPROBE(release_pages_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (69 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/remove_vma")
int BPF_KPROBE(remove_vma)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (70 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/remove_vma")
int BPF_KRETPROBE(remove_vma_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (70 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/rmqueue_bulk")
int BPF_KPROBE(rmqueue_bulk)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (71 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/rmqueue_bulk")
int BPF_KRETPROBE(rmqueue_bulk_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (71 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/selinux_file_mprotect")
int BPF_KPROBE(selinux_file_mprotect)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (72 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/selinux_file_mprotect")
int BPF_KRETPROBE(selinux_file_mprotect_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (72 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/try_charge_memcg")
int BPF_KPROBE(try_charge_memcg)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (73 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/try_charge_memcg")
int BPF_KRETPROBE(try_charge_memcg_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (73 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/uncharge_folio")
int BPF_KPROBE(uncharge_folio)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (74 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/uncharge_folio")
int BPF_KRETPROBE(uncharge_folio_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (74 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/unlock_page_memcg")
int BPF_KPROBE(unlock_page_memcg)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (75 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/unlock_page_memcg")
int BPF_KRETPROBE(unlock_page_memcg_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (75 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/unmap_page_range")
int BPF_KPROBE(unmap_page_range)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (76 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/unmap_page_range")
int BPF_KRETPROBE(unmap_page_range_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (76 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/unmap_vmas")
int BPF_KPROBE(unmap_vmas)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (77 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/unmap_vmas")
int BPF_KRETPROBE(unmap_vmas_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (77 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/up_read")
int BPF_KPROBE(up_read)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (78 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/up_read")
int BPF_KRETPROBE(up_read_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (78 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/up_write")
int BPF_KPROBE(up_write)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (79 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/up_write")
int BPF_KRETPROBE(up_write_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (79 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/vm_area_dup")
int BPF_KPROBE(vm_area_dup)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (80 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/vm_area_dup")
int BPF_KRETPROBE(vm_area_dup_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (80 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/vm_normal_page")
int BPF_KPROBE(vm_normal_page)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (81 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/vm_normal_page")
int BPF_KRETPROBE(vm_normal_page_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (81 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/vma_gap_callbacks_rotate")
int BPF_KPROBE(vma_gap_callbacks_rotate)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (82 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/vma_gap_callbacks_rotate")
int BPF_KRETPROBE(vma_gap_callbacks_rotate_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (82 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kprobe/vmacache_find")
int BPF_KPROBE(vmacache_find)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}

	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (83 << 4);
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}

SEC("kretprobe/vmacache_find")
int BPF_KRETPROBE(vmacache_find_exit)
{
	pid_t pid;
	if ((pid = bpf_get_current_pid_tgid() >> 32) != process_pid || process_pid == 0) {
		return 0;
	}
	/* reserve sample from BPF ringbuf */
	struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
	if (!e) {
		events_lost++;
		return 0;
	}

	// 32 lowest bits: pid, 32 upper bits: func ID (28b) + event type (4b)
	e->data[0] = (83 << 4) | 0x1;
	// Make it the upper bits
	e->data[0] <<= 32;
	// Add PID
	e->data[0] |= pid;
	e->data[1] = bpf_ktime_get_ns();
	/* successfully submit it to user-space for post-processing */
	bpf_ringbuf_submit(e, 0);
	return 0;
}
