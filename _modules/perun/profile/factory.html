<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>perun.profile.factory &#8212; Perun 0.21.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/perun.css?v=25c05b3f" />
    <script src="../../../_static/documentation_options.js?v=6081af2d"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for perun.profile.factory</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Profile factory optimizes the previous profile format</span>

<span class="sd">In particular, in the new format we propose to merge some regions into</span>
<span class="sd">so called resource types, which are dictionaries of persistent less</span>
<span class="sd">frequently changed aspects of resources. Moreover, we optimize other</span>
<span class="sd">regions and flatten the format.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">MutableMapping</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">click</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">perun.utils.structs</span> <span class="kn">import</span> <span class="n">ModelRecord</span>

<span class="kn">import</span> <span class="nn">perun.profile.convert</span> <span class="k">as</span> <span class="nn">convert</span>
<span class="kn">import</span> <span class="nn">perun.profile.query</span> <span class="k">as</span> <span class="nn">query</span>
<span class="kn">import</span> <span class="nn">perun.logic.config</span> <span class="k">as</span> <span class="nn">config</span>
<span class="kn">import</span> <span class="nn">perun.utils.log</span> <span class="k">as</span> <span class="nn">log</span>

<span class="kn">from</span> <span class="nn">perun.check.general_detection</span> <span class="kn">import</span> <span class="n">get_filtered_best_models_of</span>
<span class="kn">from</span> <span class="nn">perun.postprocess.regression_analysis.regression_models</span> <span class="kn">import</span> <span class="n">get_supported_models</span>
<span class="kn">from</span> <span class="nn">perun.postprocess.regressogram.methods</span> <span class="kn">import</span> <span class="n">get_supported_nparam_methods</span>


<div class="viewcode-block" id="Profile">
<a class="viewcode-back" href="../../../profile.html#perun.profile.factory.Profile">[docs]</a>
<span class="k">class</span> <span class="nc">Profile</span><span class="p">(</span><span class="n">MutableMapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :ivar dict _storage: internal storage of the profile</span>
<span class="sd">    :ivar dict _tuple_to_resource_type_map: map of tuple of persistent records of resources to</span>
<span class="sd">        unique identifier of those resources</span>
<span class="sd">    :ivar Counter _uid_counter: counter of how many resources type uid has</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">collectable</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;amount&quot;</span><span class="p">,</span>
        <span class="s2">&quot;structure-unit-size&quot;</span><span class="p">,</span>
        <span class="s2">&quot;call-order&quot;</span><span class="p">,</span>
        <span class="s2">&quot;order&quot;</span><span class="p">,</span>
        <span class="s2">&quot;address&quot;</span><span class="p">,</span>
        <span class="s2">&quot;timestamp&quot;</span><span class="p">,</span>
        <span class="s2">&quot;exclusive&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">persistent</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;trace&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;subtype&quot;</span><span class="p">,</span> <span class="s2">&quot;uid&quot;</span><span class="p">,</span> <span class="s2">&quot;location&quot;</span><span class="p">}</span>

    <span class="n">independent</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;structure-unit-size&quot;</span><span class="p">,</span>
        <span class="s2">&quot;snapshot&quot;</span><span class="p">,</span>
        <span class="s2">&quot;order&quot;</span><span class="p">,</span>
        <span class="s2">&quot;call-order&quot;</span><span class="p">,</span>
        <span class="s2">&quot;address&quot;</span><span class="p">,</span>
        <span class="s2">&quot;timestamp&quot;</span><span class="p">,</span>
        <span class="s2">&quot;exclusive&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">dependent</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;amount&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the internal storage</span>

<span class="sd">        :param list args: positional arguments for dictionary</span>
<span class="sd">        :param kwargs kwargs: keyword arguments for dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">initialization_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">global_data</span> <span class="o">=</span> <span class="n">initialization_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;models&quot;</span><span class="p">:</span> <span class="p">[]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;resources&quot;</span><span class="p">:</span> <span class="p">{},</span>
            <span class="s2">&quot;resource_type_map&quot;</span><span class="p">:</span> <span class="p">{},</span>
            <span class="s2">&quot;models&quot;</span><span class="p">:</span> <span class="n">global_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;models&quot;</span><span class="p">,</span> <span class="p">[])</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">global_data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="p">[],</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tuple_to_resource_type_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resource_type_to_flattened_resources_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uid_counter</span><span class="p">:</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">initialization_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;resources&quot;</span><span class="p">,</span> <span class="s2">&quot;snapshots&quot;</span><span class="p">,</span> <span class="s2">&quot;global&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_resources</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">config</span><span class="o">.</span><span class="n">runtime</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;context.profiles&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_resources</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">resource_list</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">resource_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;list&quot;</span><span class="p">,</span>
        <span class="n">clear_existing_resources</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given by @p resource_type updates the storage with new flattened resources</span>

<span class="sd">        This calls appropriate functions to translate older formats of resources to the</span>
<span class="sd">        new more efficient representation.</span>

<span class="sd">        :param list resource_list: either list or dict</span>
<span class="sd">        :param str resource_type: type of the resources in the resources list,</span>
<span class="sd">            can either be snapshots (then it is list of different snapshots), global</span>
<span class="sd">            then it is old type of profile) or it can be resource l</span>
<span class="sd">        :param bool clear_existing_resources: if set to true then the actual storage will be cleared</span>
<span class="sd">            before updating the resources</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">clear_existing_resources</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;resources&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">resource_type</span> <span class="o">==</span> <span class="s2">&quot;global&quot;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">resource_list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">resource_list</span><span class="p">:</span>
            <span class="c1"># Resources are in type of {&#39;time&#39;: _, &#39;resources&#39;: []}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_translate_resources</span><span class="p">(</span>
                <span class="n">resource_list</span><span class="p">[</span><span class="s2">&quot;resources&quot;</span><span class="p">],</span> <span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">resource_list</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;0.0&quot;</span><span class="p">)}</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">resource_type</span> <span class="o">==</span> <span class="s2">&quot;snapshots&quot;</span><span class="p">:</span>
            <span class="c1"># Resources are in type of [{&#39;time&#39;: _, &#39;resources&#39;: []}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">snapshot</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">resource_list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_translate_resources</span><span class="p">(</span>
                    <span class="n">snapshot</span><span class="p">[</span><span class="s2">&quot;resources&quot;</span><span class="p">],</span>
                    <span class="p">{</span><span class="s2">&quot;snapshot&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">snapshot</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;0.0&quot;</span><span class="p">)},</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">resource_list</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">Profile</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;resources&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">resource_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_translate_resources</span><span class="p">(</span><span class="n">resource_list</span><span class="p">,</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">_translate_resources</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">resource_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">additional_params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translate the list of resources to efficient format</span>

<span class="sd">        Given a list of resources, this is all flattened into a new format: a dictionary that</span>
<span class="sd">        maps unique resource identifiers (set of persistent properties) to list of collectable</span>
<span class="sd">        properties (such as amounts, addresses, etc.)</span>

<span class="sd">        :param resource_list: list of dictionaries, i.e. actual resources</span>
<span class="sd">        :param additional_params: additional information that are added to resources in the list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">runtime</span><span class="p">()</span><span class="o">.</span><span class="n">safe_get</span><span class="p">(</span><span class="s2">&quot;context.workload&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">ctx_persistent_properties</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ctx</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">ctx_collectable_properties</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ctx</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Update collectable and persistent keys (needed for merge)</span>
        <span class="n">Profile</span><span class="o">.</span><span class="n">persistent</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ctx</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)})</span>
        <span class="n">Profile</span><span class="o">.</span><span class="n">collectable</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ctx</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)})</span>

        <span class="k">for</span> <span class="n">resource</span> <span class="ow">in</span> <span class="n">resource_list</span><span class="p">:</span>
            <span class="n">persistent_properties</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">resource</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Profile</span><span class="o">.</span><span class="n">collectable</span>
            <span class="p">]</span> <span class="o">+</span> <span class="n">ctx_persistent_properties</span>
            <span class="n">persistent_properties</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">additional_params</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
            <span class="n">persistent_properties</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">collectable_properties</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">resource</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">Profile</span><span class="o">.</span><span class="n">collectable</span>
            <span class="p">]</span> <span class="o">+</span> <span class="n">ctx_collectable_properties</span>
            <span class="n">resource_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_resource_type</span><span class="p">(</span>
                <span class="n">resource</span><span class="p">[</span><span class="s2">&quot;uid&quot;</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">persistent_properties</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">resource_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;resources&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;resources&quot;</span><span class="p">][</span><span class="n">resource_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">key</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">collectable_properties</span>
                <span class="p">}</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">collectable_properties</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;resources&quot;</span><span class="p">][</span><span class="n">resource_type</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_resource_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">persistent_properties</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Registers tuple of persistent properties under new key or return existing one</span>

<span class="sd">        :param str uid: uid of the resource that will be used to describe the resource type</span>
<span class="sd">        :param tuple persistent_properties: tuple of persistent properties</span>
<span class="sd">        :return: uid corresponding to the tuple of persistent properties</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">property_key</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">convert</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">persistent_properties</span><span class="p">))</span>
        <span class="n">uid_key</span> <span class="o">=</span> <span class="n">convert</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">uid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">property_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tuple_to_resource_type_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">new_type</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">#</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uid_key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uid_counter</span><span class="p">[</span><span class="n">uid_key</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tuple_to_resource_type_map</span><span class="p">[</span><span class="n">property_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_uid_counter</span><span class="p">[</span><span class="n">uid_key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;resource_type_map&quot;</span><span class="p">][</span><span class="n">new_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">persistent_properties</span>
            <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tuple_to_resource_type_map</span><span class="p">[</span><span class="n">property_key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the item stored in profile</span>

<span class="sd">        Note: No translation of resources is performed! Use all_resources instead!</span>

<span class="sd">        :param str item: key of the item we are getting</span>
<span class="sd">        :return: item stored in the profile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the value into the storage under the key.</span>

<span class="sd">        Internally this finds a similar regions and registers them in either</span>
<span class="sd">        resource or config map.</span>

<span class="sd">        Note: No translation of resources is performed! Use update_resources instead!</span>

<span class="sd">        :param str key: key of the value</span>
<span class="sd">        :param object value:  object we are setting in the profile</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes the item in the storage</span>

<span class="sd">        :param str key: key to be deleted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterates through all of the stuff in storage.</span>

<span class="sd">        :return: storage iterator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the size of the internal storage</span>

<span class="sd">        :return: size of the internal storage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns serializable representation of the profile</span>

<span class="sd">        :return: serializable representation (i.e. the actual storage)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span>

    <span class="k">def</span> <span class="nf">_get_flattened_persistent_values_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resource_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flattens the nested values of the resources to single level</span>

<span class="sd">        E.g. the following resource:</span>

<span class="sd">        .. code-block:: json</span>

<span class="sd">            {</span>
<span class="sd">                &quot;type&quot;: &quot;memory&quot;,</span>
<span class="sd">                &quot;amount&quot;: 4,</span>
<span class="sd">                &quot;uid&quot;: {</span>
<span class="sd">                    &quot;source&quot;: &quot;../memory_collect_test.c&quot;,</span>
<span class="sd">                    &quot;function&quot;: &quot;main&quot;,</span>
<span class="sd">                    &quot;line&quot;: 22</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        is flattened as follows::</span>

<span class="sd">            {</span>
<span class="sd">                &quot;type&quot;: &quot;memory&quot;,</span>
<span class="sd">                &quot;amount&quot;: 4,</span>
<span class="sd">                &quot;uid&quot;: &quot;../memory_collect_test.c:main:22&quot;,</span>
<span class="sd">                &quot;uid:source&quot;: &quot;../memory_collect_test.c&quot;,</span>
<span class="sd">                &quot;uid:function&quot;: &quot;main&quot;,</span>
<span class="sd">                &quot;uid:line&quot;: 22</span>
<span class="sd">            }</span>

<span class="sd">        :param str resource_type: type of the resource</span>
<span class="sd">        :return: flattened resource</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">resource_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resource_type_to_flattened_resources_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">persistent_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;resource_type_map&quot;</span><span class="p">][</span><span class="n">resource_type</span><span class="p">]</span>
            <span class="n">flattened_resources</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">all_items_of</span><span class="p">(</span><span class="n">persistent_properties</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_resource_type_to_flattened_resources_map</span><span class="p">[</span><span class="n">resource_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">flattened_resources</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resource_type_to_flattened_resources_map</span><span class="p">[</span><span class="n">resource_type</span><span class="p">]</span>

<div class="viewcode-block" id="Profile.all_resources">
<a class="viewcode-back" href="../../../profile.html#perun.profile.factory.Profile.all_resources">[docs]</a>
    <span class="k">def</span> <span class="nf">all_resources</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flatten_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generator for iterating through all the resources contained in the</span>
<span class="sd">        performance profile.</span>

<span class="sd">        Generator iterates through all the snapshots, and subsequently yields</span>
<span class="sd">        collected resources. For more thorough description of format of resources</span>
<span class="sd">        refer to :pkey:`resources`. Resources are not flattened and, thus, can</span>
<span class="sd">        contain nested dictionaries (e.g. for `traces` or `uids`).</span>

<span class="sd">        :param bool flatten_values: if set to true, then the persistent values will</span>
<span class="sd">            be flattened to one level.</span>
<span class="sd">        :returns: iterable stream of resources represented as pair ``(int, dict)``</span>
<span class="sd">            of snapshot number and the resources w.r.t. the specification of the</span>
<span class="sd">            :pkey:`resources`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">resource_type</span><span class="p">,</span> <span class="n">resources</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;resources&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># uid: {...}</span>
            <span class="k">if</span> <span class="n">flatten_values</span><span class="p">:</span>
                <span class="n">persistent_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_flattened_persistent_values_for</span><span class="p">(</span><span class="n">resource_type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">persistent_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;resource_type_map&quot;</span><span class="p">][</span><span class="n">resource_type</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">resources</span><span class="p">:</span>
                <span class="n">resource_keys</span> <span class="o">=</span> <span class="n">resources</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">resource_values</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">resources</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="c1"># collectable values should be flat</span>
                    <span class="n">collectable_properties</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">resource_keys</span><span class="p">,</span> <span class="n">resource_values</span><span class="p">))</span>
                    <span class="n">collectable_properties</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">persistent_properties</span><span class="p">)</span>
                    <span class="n">snapshot_number</span> <span class="o">=</span> <span class="n">collectable_properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;snapshot&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">snapshot_number</span><span class="p">,</span> <span class="n">collectable_properties</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># In case we have only persistent properties</span>
                <span class="k">yield</span> <span class="n">persistent_properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;snapshot&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">persistent_properties</span></div>


    <span class="k">def</span> <span class="nf">all_resource_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generator for iterating through all the fields (both flattened and</span>
<span class="sd">        original) that are occurring in the resources.</span>

<span class="sd">        E.g. considering the example profiles from :pkey:`resources`, the function</span>
<span class="sd">        yields the following for `memory`, `time` and `trace` profiles</span>
<span class="sd">        respectively (considering we convert the stream to list)::</span>

<span class="sd">            memory_resource_fields = [</span>
<span class="sd">                &#39;type&#39;, &#39;address&#39;, &#39;amount&#39;, &#39;uid:function&#39;, &#39;uid:source&#39;,</span>
<span class="sd">                &#39;uid:line&#39;, &#39;uid&#39;, &#39;trace&#39;, &#39;subtype&#39;</span>
<span class="sd">            ]</span>
<span class="sd">            time_resource_fields = [</span>
<span class="sd">                &#39;type&#39;, &#39;amount&#39;, &#39;uid&#39;</span>
<span class="sd">            ]</span>
<span class="sd">            complexity_resource_fields = [</span>
<span class="sd">                &#39;type&#39;, &#39;amount&#39;, &#39;structure-unit-size&#39;, &#39;subtype&#39;, &#39;uid&#39;</span>
<span class="sd">            ]</span>

<span class="sd">        :returns: iterable stream of resource field keys represented as `str`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">resource_type</span><span class="p">,</span> <span class="n">resources</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;resources&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># uid: {...}</span>
            <span class="n">persistent_properties</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">all_items_of</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;resource_type_map&quot;</span><span class="p">][</span><span class="n">resource_type</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">resources</span><span class="p">:</span>
                <span class="n">keys</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">resources</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">keys</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">persistent_properties</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">keys</span>

<div class="viewcode-block" id="Profile.all_filtered_models">
<a class="viewcode-back" href="../../../profile.html#perun.profile.factory.Profile.all_filtered_models">[docs]</a>
    <span class="k">def</span> <span class="nf">all_filtered_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">models_strategy</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ModelRecord</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The function obtains models according to the given strategy.</span>

<span class="sd">        This function according to the given strategy and group derived from it</span>
<span class="sd">        obtains the models from the current profile. The function creates the</span>
<span class="sd">        relevant dictionary with required models or calls the responded functions,</span>
<span class="sd">        that returns the models according to the specifications.</span>

<span class="sd">        :param str models_strategy: name of detection models strategy to obtains relevant models</span>
<span class="sd">        :return ModelRecord: required models</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">models_strategy</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">models_strategy</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;all-param&quot;</span><span class="p">,</span> <span class="s2">&quot;all-nonparam&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">get_filtered_best_models_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">,</span> <span class="n">model_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">models_strategy</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;best-nonparam&quot;</span><span class="p">,</span> <span class="s2">&quot;best-model&quot;</span><span class="p">,</span> <span class="s2">&quot;best-param&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">get_filtered_best_models_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="Profile.all_models">
<a class="viewcode-back" href="../../../profile.html#perun.profile.factory.Profile.all_models">[docs]</a>
    <span class="k">def</span> <span class="nf">all_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;model&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generator of all &#39;models&#39; records from the performance profile w.r.t.</span>
<span class="sd">        :ref:`profile-spec`.</span>

<span class="sd">        Form a profile, postprocessed by e.g. :ref:`postprocessors-regression-analysis`</span>
<span class="sd">        and iterates through all of its models (for more details about models refer</span>
<span class="sd">        to :pkey:`models` or :ref:`postprocessors-regression-analysis`).</span>

<span class="sd">        E.g. given some trace profile ``complexity_prof``, we can iterate its</span>
<span class="sd">        models as follows:</span>

<span class="sd">            &gt;&gt;&gt; gen = complexity_prof.all_models()</span>
<span class="sd">            &gt;&gt;&gt; gen.__next__()</span>
<span class="sd">            (0, {&#39;x_start&#39;: 0, &#39;model&#39;: &#39;constant&#39;, &#39;method&#39;: &#39;full&#39;,</span>
<span class="sd">            &#39;coeffs&#39;: [{&#39;name&#39;: &#39;b0&#39;, &#39;value&#39;: 0.5644496762801648}, {&#39;name&#39;: &#39;b1&#39;,</span>
<span class="sd">            &#39;value&#39;: 0.0}], &#39;uid&#39;: &#39;SLList_insert(SLList*, int)&#39;, &#39;r_square&#39;: 0.0,</span>
<span class="sd">            &#39;x_end&#39;: 11892})</span>
<span class="sd">            &gt;&gt;&gt; gen.__next__()</span>
<span class="sd">            (1, {&#39;x_start&#39;: 0, &#39;model&#39;: &#39;exponential&#39;, &#39;method&#39;: &#39;full&#39;,</span>
<span class="sd">            &#39;coeffs&#39;: [{&#39;name&#39;: &#39;b0&#39;, &#39;value&#39;: 0.9909792049684152}, {&#39;name&#39;: &#39;b1&#39;,</span>
<span class="sd">            &#39;value&#39;: 1.000004056250301}], &#39;uid&#39;: &#39;SLList_insert(SLList*, int)&#39;,</span>
<span class="sd">            &#39;r_square&#39;: 0.007076437903106431, &#39;x_end&#39;: 11892})</span>


<span class="sd">        :param str group: the kind of requested models to return</span>
<span class="sd">        :returns: iterable stream of ``(int, dict)`` pairs, where first yields the</span>
<span class="sd">            positional number of model and latter correponds to one &#39;models&#39;</span>
<span class="sd">            record (for more details about models refer to :pkey:`models` or</span>
<span class="sd">            :ref:`postprocessors-regression-analysis`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">model_idx</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;models&quot;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">group</span> <span class="o">==</span> <span class="s2">&quot;model&quot;</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">group</span> <span class="o">==</span> <span class="s2">&quot;param&quot;</span> <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;model&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">get_supported_models</span><span class="p">())</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">group</span> <span class="o">==</span> <span class="s2">&quot;nonparam&quot;</span> <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;model&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">get_supported_nparam_methods</span><span class="p">())</span>
            <span class="p">):</span>
                <span class="k">yield</span> <span class="n">model_idx</span><span class="p">,</span> <span class="n">model</span></div>


    <span class="k">def</span> <span class="nf">get_model_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds specific model from profile according to the</span>
<span class="sd">        given kind of model and specific unique identification.</span>

<span class="sd">        :param str model_type: specific kind of required model (e.g. regressogram, constant, etc.)</span>
<span class="sd">        :param str uid: specific unique identification of required model</span>
<span class="sd">        :return dict: model with all its relevant items</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;models&quot;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="n">model</span><span class="p">[</span><span class="s2">&quot;model&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">model</span><span class="p">[</span><span class="s2">&quot;uid&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">uid</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">model</span>
        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;missing </span><span class="si">{</span><span class="n">model_type</span><span class="si">}</span><span class="s2"> model for uid &#39;</span><span class="si">{</span><span class="n">uid</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{}</span>  <span class="c1"># this is only for type checking, in reality it is dead code</span>

<div class="viewcode-block" id="Profile.all_snapshots">
<a class="viewcode-back" href="../../../profile.html#perun.profile.factory.Profile.all_snapshots">[docs]</a>
    <span class="k">def</span> <span class="nf">all_snapshots</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterates through all the snapshots in resources</span>

<span class="sd">        Note this is required e.g. for heap map, which needs to group the resources by</span>
<span class="sd">        snapshots.</span>

<span class="sd">        :return: iterable of snapshot numbers and snapshot resources</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_resources</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_resources</span><span class="p">())</span>
        <span class="n">all_resources</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">snapshot_map</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">number_of</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">all_resources</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
            <span class="n">snapshot_map</span><span class="p">[</span><span class="n">number_of</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">res</span><span class="p">))</span>
        <span class="n">maximal_snapshot</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">snapshot_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maximal_snapshot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">i</span><span class="p">,</span> <span class="n">snapshot_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>


    <span class="c1"># TODO: discuss the intent of __len__ and possibly merge?</span>
    <span class="k">def</span> <span class="nf">resources_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of resources stored in the internal storage.</span>

<span class="sd">        :return int: the number of stored resources</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="s2">&quot;resources&quot;</span><span class="p">])</span></div>



<span class="c1"># Click helper</span>
<span class="n">pass_profile</span> <span class="o">=</span> <span class="n">click</span><span class="o">.</span><span class="n">make_pass_decorator</span><span class="p">(</span><span class="n">Profile</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><p class="logo">
  <a href="../../../index.html">
    <h3>Perun</h3>
  </a>
</p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Tomas Fiedor, Jiri Pavela, Simon Stupinsky, et al..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>