<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Postprocessors Overview &#8212; Perun 0.21.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/perun.css?v=25c05b3f" />
    <script src="_static/documentation_options.js?v=ab083fe0"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Visualizations Overview" href="views.html" />
    <link rel="prev" title="Collectors Overview" href="collectors.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-perun.postprocess">
<span id="id1"></span><span id="postprocessors-overview"></span><h1>Postprocessors Overview<a class="headerlink" href="#module-perun.postprocess" title="Link to this heading">¶</a></h1>
<p>Performance profiles originate either from the user’s own means (i.e. by
building their own collectors and generating the profiles w.r.t
<a class="reference internal" href="profile.html#profile-spec"><span class="std std-ref">Specification of Profile Format</span></a>) or using one of the collectors from Perun’s tool suite.</p>
<p>Perun can postprocess such profiling data in two ways:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>By <strong>Directly running postprocessors</strong> through <code class="docutils literal notranslate"><span class="pre">perun</span> <span class="pre">postprocessby</span></code>
command, that takes the profile (either stored or pending) and uses a
single postprocessor with given configuration.</p></li>
<li><p>By <strong>Using job specification</strong> either as a single run of batch of
profiling jobs using <code class="docutils literal notranslate"><span class="pre">perun</span> <span class="pre">run</span> <span class="pre">job</span></code> or according to the specification
of the so called job matrix using <code class="docutils literal notranslate"><span class="pre">perun</span> <span class="pre">run</span> <span class="pre">matrix</span></code> command.</p></li>
</ol>
</div></blockquote>
<p>The format of input and resulting profiles has to be w.r.t.
<a class="reference internal" href="profile.html#profile-spec"><span class="std std-ref">Specification of Profile Format</span></a>. By default new profiles are created. The <a class="reference internal" href="profile.html#perfreg-origin"><code class="xref std std-preg docutils literal notranslate"><span class="pre">origin</span></code></a>
set to the origin of the original profile. Further, <a class="reference internal" href="profile.html#perfreg-postprocessors"><code class="xref std std-preg docutils literal notranslate"><span class="pre">postprocessors</span></code></a> is
extended with configuration of the run postprocessor (appended at the end).</p>
<p>All of the postprocessed profiles are stored in the <code class="docutils literal notranslate"><span class="pre">.perun/jobs/</span></code> directory
as a file with the <code class="docutils literal notranslate"><span class="pre">.perf</span></code> extension. The filename is by default
automatically generated according to the following template:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bin</span><span class="o">-</span><span class="n">collector</span><span class="o">-</span><span class="n">workload</span><span class="o">-</span><span class="n">timestamp</span><span class="o">.</span><span class="n">perf</span>
</pre></div>
</div>
<p>Profiles can be further registered and stored in persistent storage using
<code class="docutils literal notranslate"><span class="pre">perun</span> <span class="pre">add</span></code> command.  Then both stored and pending profiles (i.e. those not
yet assigned) can be interpreted using available interpretation techniques
using <code class="docutils literal notranslate"><span class="pre">perun</span> <span class="pre">show</span></code>.  Refer to <a class="reference internal" href="cli.html"><span class="doc">Command Line Interface</span></a> and <a class="reference internal" href="views.html"><span class="doc">Visualizations Overview</span></a> for more details
about running command line commands and capabilities fo interpretation
techniques respectively. Internals of perun storage is described in
<a class="reference internal" href="internals.html"><span class="doc">Perun Internals</span></a>.</p>
<a class="reference internal image-reference" href="_images/architecture-postprocessors.svg"><img alt="_images/architecture-postprocessors.svg" class="align-center" src="_images/architecture-postprocessors.svg" width="100%" /></a>
<section id="supported-postprocessors">
<span id="postprocessors-list"></span><h2>Supported Postprocessors<a class="headerlink" href="#supported-postprocessors" title="Link to this heading">¶</a></h2>
<p>Perun’s tool suite currently contains the following five postprocessors:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><a class="reference internal" href="#postprocessors-normalizer"><span class="std std-ref">Normalizer Postprocessor</span></a> scales the resources of the given profile to the
interval (0, 1). The main intuition behind the usage of this postprocessor is to be able to
compare profiles from different workloads or parameters, which may have different scales of
resource amounts.</p></li>
<li><p><a class="reference internal" href="#postprocessors-regression-analysis"><span class="std std-ref">Regression Analysis</span></a> (authored by <strong>Jirka Pavela</strong>) attempts to do a
regression analysis by finding the fitting model for dependent variable based on other
independent one. Currently the postprocessor focuses on finding a well
suited model (linear, quadratic, logarithmic, etc.) for the amount of time duration
depending on size of the data structure the function operates on.</p></li>
<li><p><a class="reference internal" href="#postprocessors-clusterizer"><span class="std std-ref">Clusterizer</span></a> tries to classify resources to uniquely identified clusters,
which can be used for further postprocessing (e.g. by regression analysis) or to group
similar amounts of resources.</p></li>
<li><p><a class="reference internal" href="#postprocessors-regressogram"><span class="std std-ref">Regressogram method</span></a> (authored by <strong>Simon Stupinsky</strong>) also known as the binning
approach, is the simplest non-parametric estimator. This method trying to fit models through
data by dividing the interval into N equal-width bucket and the resultant value in each bucket
is equal to result of selected statistical aggregation function (mean/median) within the values
in the relevant bucket. In short, we can describe the regressogram as a step function
(i.e. constant function by parts).</p></li>
<li><p><a class="reference internal" href="#postprocessors-moving-average"><span class="std std-ref">Moving Average Methods</span></a> (authored by <strong>Simon Stupinsky</strong>) also know as the rolling
average or running average, is the statistical analysis belongs to non-parametric approaches.
This method is based on the analysis of the given data points by creating a series of values based
on the specific aggregation function, most often average or possibly median. The resulting values
are derived from the different subsets of the full data set. We currently support the two main
methods of this approach and that the <strong>Simple</strong> Moving Average and the <strong>Exponential</strong> Moving
Average. In the first method is an available selection from two aggregation function: <strong>mean</strong>
or <strong>median</strong>.</p></li>
</ol>
</div></blockquote>
<p>All of the listed postprocessors can be run from command line. For more information about command
line interface for individual postprocessors refer to <a class="reference internal" href="cli.html#cli-postprocess-units-ref"><span class="std std-ref">Postprocess units</span></a>.</p>
<p>Postprocessors modules are implementation independent and only requires a simple python interface
registered within Perun. For brief tutorial how to create and register your own postprocessors
refer to <a class="reference internal" href="#postprocessors-custom"><span class="std std-ref">Creating your own Postprocessor</span></a>.</p>
<section id="module-perun.postprocess.normalizer">
<span id="normalizer-postprocessor"></span><span id="postprocessors-normalizer"></span><h3>Normalizer Postprocessor<a class="headerlink" href="#module-perun.postprocess.normalizer" title="Link to this heading">¶</a></h3>
<p>Normalizer is a simple postprocessor that normalizes the values.</p>
<section id="command-line-interface">
<h4>Command Line Interface<a class="headerlink" href="#command-line-interface" title="Link to this heading">¶</a></h4>
<section id="perun-postprocessby-normalizer">
<h5>perun postprocessby normalizer<a class="headerlink" href="#perun-postprocessby-normalizer" title="Link to this heading">¶</a></h5>
<p>Normalizes performance profile into flat interval.</p>
<div class="line-block">
<div class="line">* <strong>Limitations</strong>: <cite>none</cite></div>
<div class="line">* <strong>Dependencies</strong>: <cite>none</cite></div>
</div>
<p>Normalizer is a postprocessor, which iterates through all of the snapshots
and normalizes the resources of same type to interval <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">1</span></code> corresponds to the maximal value of the given type.</p>
<p>Consider the following list of resources for one snapshot generated by
<a class="reference internal" href="collectors.html#collectors-time"><span class="std std-ref">Time Collector</span></a>:</p>
<pre class="literal-block">[
    {
        'amount': 0.59,
        'uid': 'sys'
    }, {
        'amount': 0.32,
        'uid': 'user'
    }, {
        'amount': 2.32,
        'uid': 'real'
    }
]</pre>
<p>Normalizer yields the following set of resources:</p>
<pre class="literal-block">[
    {
        'amount': 0.2543103448275862,
        'uid': 'sys'
    }, {
        'amount': 0.13793103448275865,
        'uid': 'user'
    }, {
        'amount': 1.0,
        'uid': 'real'
    }
]</pre>
<p>Refer to <a class="reference internal" href="#postprocessors-normalizer"><span class="std std-ref">Normalizer Postprocessor</span></a> for more thorough description and
examples of <cite>normalizer</cite> postprocessor.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>normalizer<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="module-perun.postprocess.regression_analysis">
<span id="regression-analysis"></span><span id="postprocessors-regression-analysis"></span><h3>Regression Analysis<a class="headerlink" href="#module-perun.postprocess.regression_analysis" title="Link to this heading">¶</a></h3>
<p>Postprocessing of input profiles using the regression analysis. The
regression analysis offers several computational methods and models for finding
fitting models for trends in the captured profiling resources.</p>
<section id="postprocessors-regression-analysis-cli">
<span id="id2"></span><h4>Command Line Interface<a class="headerlink" href="#postprocessors-regression-analysis-cli" title="Link to this heading">¶</a></h4>
<section id="perun-postprocessby-regression-analysis">
<h5>perun postprocessby regression_analysis<a class="headerlink" href="#perun-postprocessby-regression-analysis" title="Link to this heading">¶</a></h5>
<p>Finds fitting regression models to estimate models of profiled resources.</p>
<div class="line-block">
<div class="line">* <strong>Limitations</strong>: Currently limited to models of <cite>amount</cite> depending on</div>
<div class="line-block">
<div class="line"><cite>structural-unit-size</cite></div>
</div>
<div class="line">* <strong>Dependencies</strong>: <a class="reference internal" href="collectors.html#collectors-trace"><span class="std std-ref">Trace Collector</span></a></div>
</div>
<p>Regression analyzer tries to find a fitting model to estimate the <cite>amount</cite>
of resources depending on <cite>structural-unit-size</cite>.</p>
<p>The following strategies are currently available:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><strong>Full Computation</strong> uses all of the data points to obtain the best
fitting model for each type of model from the database (unless
<code class="docutils literal notranslate"><span class="pre">--regression_models</span></code>/<code class="docutils literal notranslate"><span class="pre">-r</span></code> restrict the set of models)</p></li>
<li><p><strong>Iterative Computation</strong> uses a percentage of data points to obtain
some preliminary models together with their errors or fitness. The
most fitting model is then expanded, until it is fully computed or
some other model becomes more fitting.</p></li>
<li><p><strong>Full Computation with initial estimate</strong> first uses some percent
of data to estimate which model would be best fitting. Given model
is then fully computed.</p></li>
<li><p><strong>Interval Analysis</strong> uses more finer set of intervals of data and
estimates models for each interval providing more precise modeling
of the profile.</p></li>
<li><p><strong>Bisection Analysis</strong> fully computes the models for full interval.
Then it does a split of the interval and computes new models for
them. If the best fitting models changed for sub intervals, then we
continue with the splitting.</p></li>
</ol>
</div></blockquote>
<p>Currently we support <strong>linear</strong>, <strong>quadratic</strong>, <strong>power</strong>, <strong>logaritmic</strong>
and <strong>constant</strong> models and use the <cite>coeficient of determination</cite>
(<span class="math notranslate nohighlight">\(R^2\)</span>) to measure the fitness of model. The models are stored as
follows:</p>
<pre class="literal-block">{
    &quot;uid&quot;: &quot;SLList_insert(SLList*, int)&quot;,
    &quot;r_square&quot;: 0.0017560012128507133,
    &quot;coeffs&quot;: [
        {
            &quot;value&quot;: 0.505375215875552,
            &quot;name&quot;: &quot;b0&quot;
        },
        {
            &quot;value&quot;: 9.935159839322705e-06,
            &quot;name&quot;: &quot;b1&quot;
        }
    ],
    &quot;x_start&quot;: 0,
    &quot;x_end&quot;: 11892,
    &quot;model&quot;: &quot;linear&quot;,
    &quot;method&quot;: &quot;full&quot;,
}</pre>
<p>Note that if your data are not suitable for regression analysis, check out
<a class="reference internal" href="#postprocessors-clusterizer"><span class="std std-ref">Clusterizer</span></a> to postprocess your profile to be
analysable by this analysis.</p>
<p>For more details about regression analysis refer to
<a class="reference internal" href="#postprocessors-regression-analysis"><span class="std std-ref">Regression Analysis</span></a>. For more details how to collect
suitable resources refer to <a class="reference internal" href="collectors.html#collectors-trace"><span class="std std-ref">Trace Collector</span></a>.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>regression_analysis<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span>
</pre></div>
</div>
<p class="rubric">Options</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-regression_analysis-m">
<span id="cmdoption-perun-postprocessby-regression_analysis-method"></span><span class="sig-name descname"><span class="pre">-m</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--method</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;method&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-regression_analysis-m" title="Link to this definition">¶</a></dt>
<dd><p><strong>Required</strong> Will use the &lt;method&gt; to find the best fitting models for the given profile.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>full | iterative | interval | initial_guess | bisection</p>
</dd>
</dl>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-regression_analysis-r">
<span id="cmdoption-perun-postprocessby-regression_analysis-regression_models"></span><span class="sig-name descname"><span class="pre">-r</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--regression_models</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;regression_models&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-regression_analysis-r" title="Link to this definition">¶</a></dt>
<dd><p>Restricts the list of regression models used by the specified &lt;method&gt; to fit the data. If omitted, all regression models will be used in the computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>all | constant | exponential | linear | logarithmic | power | quadratic</p>
</dd>
</dl>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-regression_analysis-s">
<span id="cmdoption-perun-postprocessby-regression_analysis-steps"></span><span class="sig-name descname"><span class="pre">-s</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--steps</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;steps&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-regression_analysis-s" title="Link to this definition">¶</a></dt>
<dd><p>Restricts the number of number of steps / data parts used by the iterative, interval and initial guess methods</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-regression_analysis-dp">
<span id="cmdoption-perun-postprocessby-regression_analysis-depending-on"></span><span class="sig-name descname"><span class="pre">-dp</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--depending-on</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;depending_on&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-regression_analysis-dp" title="Link to this definition">¶</a></dt>
<dd><p>Sets the key that will be used as a source of independent variable.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-regression_analysis-o">
<span id="cmdoption-perun-postprocessby-regression_analysis-of"></span><span class="sig-name descname"><span class="pre">-o</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--of</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;of_resource_key&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-regression_analysis-o" title="Link to this definition">¶</a></dt>
<dd><p>Sets key for which we are finding the model.</p>
</dd></dl>

</section>
</section>
<section id="examples">
<span id="postprocessors-regression-analysis-examples"></span><h4>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="p">{</span>
<span class="linenos">  2</span><span class="w">  </span><span class="nt">&quot;resources&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">  3</span><span class="w">    </span><span class="nt">&quot;SLList_insert(SLList*, int)#0&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">  4</span><span class="w">      </span><span class="nt">&quot;amount&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="linenos">  5</span><span class="w">        </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="linenos">  6</span><span class="w">      </span><span class="p">],</span>
<span class="linenos">  7</span><span class="w">      </span><span class="nt">&quot;structure-unit-size&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="linenos">  8</span><span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span>
<span class="linenos">  9</span><span class="w">      </span><span class="p">]</span>
<span class="linenos"> 10</span><span class="w">    </span><span class="p">},</span>
<span class="linenos"> 11</span><span class="w">    </span><span class="nt">&quot;SLList_destroy(SLList*)#0&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 12</span><span class="w">      </span><span class="nt">&quot;amount&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="linenos"> 13</span><span class="w">        </span><span class="mi">1</span>
<span class="linenos"> 14</span><span class="w">      </span><span class="p">],</span>
<span class="linenos"> 15</span><span class="w">      </span><span class="nt">&quot;structure-unit-size&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="linenos"> 16</span><span class="w">        </span><span class="mi">4</span>
<span class="linenos"> 17</span><span class="w">      </span><span class="p">]</span>
<span class="linenos"> 18</span><span class="w">    </span><span class="p">},</span>
<span class="linenos"> 19</span><span class="w">    </span><span class="nt">&quot;SLList_init(SLList*)#0&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 20</span><span class="w">      </span><span class="nt">&quot;amount&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="linenos"> 21</span><span class="w">        </span><span class="mi">6</span>
<span class="linenos"> 22</span><span class="w">      </span><span class="p">],</span>
<span class="linenos"> 23</span><span class="w">      </span><span class="nt">&quot;structure-unit-size&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="linenos"> 24</span><span class="w">        </span><span class="mi">0</span>
<span class="linenos"> 25</span><span class="w">      </span><span class="p">]</span>
<span class="linenos"> 26</span><span class="w">    </span><span class="p">},</span>
<span class="linenos"> 27</span><span class="w">    </span><span class="nt">&quot;SLList_search(SLList*, int)#0&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 28</span><span class="w">      </span><span class="nt">&quot;amount&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="linenos"> 29</span><span class="w">        </span><span class="mi">0</span>
<span class="linenos"> 30</span><span class="w">      </span><span class="p">],</span>
<span class="linenos"> 31</span><span class="w">      </span><span class="nt">&quot;structure-unit-size&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="linenos"> 32</span><span class="w">        </span><span class="mi">0</span>
<span class="linenos"> 33</span><span class="w">      </span><span class="p">]</span>
<span class="linenos"> 34</span><span class="w">    </span><span class="p">}</span>
<span class="linenos"> 35</span><span class="w">  </span><span class="p">},</span>
<span class="linenos"> 36</span><span class="w">  </span><span class="nt">&quot;header&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 37</span><span class="w">    </span><span class="nt">&quot;workload&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="linenos"> 38</span><span class="w">    </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mixed&quot;</span><span class="p">,</span>
<span class="linenos"> 39</span><span class="w">    </span><span class="nt">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 40</span><span class="w">      </span><span class="nt">&quot;mixed(time delta)&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;us&quot;</span>
<span class="linenos"> 41</span><span class="w">    </span><span class="p">},</span>
<span class="linenos"> 42</span><span class="w">    </span><span class="nt">&quot;params&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="linenos"> 43</span><span class="w">    </span><span class="nt">&quot;cmd&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;../stap-collector/tst&quot;</span>
<span class="hll"><span class="linenos"> 44</span><span class="w">  </span><span class="p">},</span>
</span><span class="hll"><span class="linenos"> 45</span><span class="w">  </span><span class="nt">&quot;models&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
</span><span class="hll"><span class="linenos"> 46</span><span class="w">    </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 47</span><span class="w">      </span><span class="nt">&quot;coeffs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
</span><span class="hll"><span class="linenos"> 48</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 49</span><span class="w">          </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.75</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 50</span><span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b0&quot;</span>
</span><span class="hll"><span class="linenos"> 51</span><span class="w">        </span><span class="p">},</span>
</span><span class="hll"><span class="linenos"> 52</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 53</span><span class="w">          </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 54</span><span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b1&quot;</span>
</span><span class="hll"><span class="linenos"> 55</span><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="linenos"> 56</span><span class="w">      </span><span class="p">],</span>
</span><span class="hll"><span class="linenos"> 57</span><span class="w">      </span><span class="nt">&quot;method&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;full&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 58</span><span class="w">      </span><span class="nt">&quot;r_square&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 59</span><span class="w">      </span><span class="nt">&quot;model&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 60</span><span class="w">      </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;SLList_insert(SLList*, int)&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 61</span><span class="w">      </span><span class="nt">&quot;x_interval_end&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 62</span><span class="w">      </span><span class="nt">&quot;x_interval_start&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span>
</span><span class="hll"><span class="linenos"> 63</span><span class="w">    </span><span class="p">},</span>
</span><span class="hll"><span class="linenos"> 64</span><span class="w">    </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 65</span><span class="w">      </span><span class="nt">&quot;coeffs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
</span><span class="hll"><span class="linenos"> 66</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 67</span><span class="w">          </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 68</span><span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b0&quot;</span>
</span><span class="hll"><span class="linenos"> 69</span><span class="w">        </span><span class="p">},</span>
</span><span class="hll"><span class="linenos"> 70</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 71</span><span class="w">          </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 72</span><span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b1&quot;</span>
</span><span class="hll"><span class="linenos"> 73</span><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="linenos"> 74</span><span class="w">      </span><span class="p">],</span>
</span><span class="hll"><span class="linenos"> 75</span><span class="w">      </span><span class="nt">&quot;method&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;full&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 76</span><span class="w">      </span><span class="nt">&quot;r_square&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 77</span><span class="w">      </span><span class="nt">&quot;model&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;exponential&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 78</span><span class="w">      </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;SLList_insert(SLList*, int)&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 79</span><span class="w">      </span><span class="nt">&quot;x_interval_end&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 80</span><span class="w">      </span><span class="nt">&quot;x_interval_start&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span>
</span><span class="hll"><span class="linenos"> 81</span><span class="w">    </span><span class="p">},</span>
</span><span class="hll"><span class="linenos"> 82</span><span class="w">    </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 83</span><span class="w">      </span><span class="nt">&quot;coeffs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
</span><span class="hll"><span class="linenos"> 84</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 85</span><span class="w">          </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.6</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 86</span><span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b0&quot;</span>
</span><span class="hll"><span class="linenos"> 87</span><span class="w">        </span><span class="p">},</span>
</span><span class="hll"><span class="linenos"> 88</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 89</span><span class="w">          </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.1</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 90</span><span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b1&quot;</span>
</span><span class="hll"><span class="linenos"> 91</span><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="linenos"> 92</span><span class="w">      </span><span class="p">],</span>
</span><span class="hll"><span class="linenos"> 93</span><span class="w">      </span><span class="nt">&quot;method&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;full&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 94</span><span class="w">      </span><span class="nt">&quot;r_square&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.06666666666666667</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 95</span><span class="w">      </span><span class="nt">&quot;model&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 96</span><span class="w">      </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;SLList_insert(SLList*, int)&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 97</span><span class="w">      </span><span class="nt">&quot;x_interval_end&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
</span><span class="hll"><span class="linenos"> 98</span><span class="w">      </span><span class="nt">&quot;x_interval_start&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span>
</span><span class="hll"><span class="linenos"> 99</span><span class="w">    </span><span class="p">},</span>
</span><span class="hll"><span class="linenos">100</span><span class="w">    </span><span class="p">{</span>
</span><span class="hll"><span class="linenos">101</span><span class="w">      </span><span class="nt">&quot;coeffs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
</span><span class="hll"><span class="linenos">102</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos">103</span><span class="w">          </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.08877935258260898</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">104</span><span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b0&quot;</span>
</span><span class="hll"><span class="linenos">105</span><span class="w">        </span><span class="p">},</span>
</span><span class="hll"><span class="linenos">106</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos">107</span><span class="w">          </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.9675751528184126</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">108</span><span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b1&quot;</span>
</span><span class="hll"><span class="linenos">109</span><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="linenos">110</span><span class="w">      </span><span class="p">],</span>
</span><span class="hll"><span class="linenos">111</span><span class="w">      </span><span class="nt">&quot;method&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;full&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">112</span><span class="w">      </span><span class="nt">&quot;r_square&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.8668309711260865</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">113</span><span class="w">      </span><span class="nt">&quot;model&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;logarithmic&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">114</span><span class="w">      </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;SLList_insert(SLList*, int)&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">115</span><span class="w">      </span><span class="nt">&quot;x_interval_end&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">116</span><span class="w">      </span><span class="nt">&quot;x_interval_start&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span>
</span><span class="hll"><span class="linenos">117</span><span class="w">    </span><span class="p">},</span>
</span><span class="hll"><span class="linenos">118</span><span class="w">    </span><span class="p">{</span>
</span><span class="hll"><span class="linenos">119</span><span class="w">      </span><span class="nt">&quot;coeffs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
</span><span class="hll"><span class="linenos">120</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos">121</span><span class="w">          </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">122</span><span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b0&quot;</span>
</span><span class="hll"><span class="linenos">123</span><span class="w">        </span><span class="p">},</span>
</span><span class="hll"><span class="linenos">124</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos">125</span><span class="w">          </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">126</span><span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b1&quot;</span>
</span><span class="hll"><span class="linenos">127</span><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="linenos">128</span><span class="w">      </span><span class="p">],</span>
</span><span class="hll"><span class="linenos">129</span><span class="w">      </span><span class="nt">&quot;method&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;full&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">130</span><span class="w">      </span><span class="nt">&quot;r_square&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">131</span><span class="w">      </span><span class="nt">&quot;model&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;power&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">132</span><span class="w">      </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;SLList_insert(SLList*, int)&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">133</span><span class="w">      </span><span class="nt">&quot;x_interval_end&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">134</span><span class="w">      </span><span class="nt">&quot;x_interval_start&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span>
</span><span class="hll"><span class="linenos">135</span><span class="w">    </span><span class="p">},</span>
</span><span class="hll"><span class="linenos">136</span><span class="w">    </span><span class="p">{</span>
</span><span class="hll"><span class="linenos">137</span><span class="w">      </span><span class="nt">&quot;coeffs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
</span><span class="hll"><span class="linenos">138</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos">139</span><span class="w">          </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.5714285714285714</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">140</span><span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b0&quot;</span>
</span><span class="hll"><span class="linenos">141</span><span class="w">        </span><span class="p">},</span>
</span><span class="hll"><span class="linenos">142</span><span class="w">        </span><span class="p">{</span>
</span><span class="hll"><span class="linenos">143</span><span class="w">          </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.05102040816326531</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">144</span><span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;b1&quot;</span>
</span><span class="hll"><span class="linenos">145</span><span class="w">        </span><span class="p">}</span>
</span><span class="hll"><span class="linenos">146</span><span class="w">      </span><span class="p">],</span>
</span><span class="hll"><span class="linenos">147</span><span class="w">      </span><span class="nt">&quot;method&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;full&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">148</span><span class="w">      </span><span class="nt">&quot;r_square&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.17006802721088435</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">149</span><span class="w">      </span><span class="nt">&quot;model&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;quadratic&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">150</span><span class="w">      </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;SLList_insert(SLList*, int)&quot;</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">151</span><span class="w">      </span><span class="nt">&quot;x_interval_end&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
</span><span class="hll"><span class="linenos">152</span><span class="w">      </span><span class="nt">&quot;x_interval_start&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span>
</span><span class="hll"><span class="linenos">153</span><span class="w">    </span><span class="p">}</span>
</span><span class="linenos">154</span><span class="w">  </span><span class="p">],</span>
<span class="linenos">155</span><span class="w">  </span><span class="nt">&quot;collector_info&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">156</span><span class="w">    </span><span class="nt">&quot;params&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">157</span><span class="w">      </span><span class="nt">&quot;global_sampling&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span>
<span class="linenos">158</span><span class="w">      </span><span class="nt">&quot;sampling&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="linenos">159</span><span class="w">        </span><span class="p">{</span>
<span class="linenos">160</span><span class="w">          </span><span class="nt">&quot;func&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;SLList_insert&quot;</span><span class="p">,</span>
<span class="linenos">161</span><span class="w">          </span><span class="nt">&quot;sample&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span>
<span class="linenos">162</span><span class="w">        </span><span class="p">},</span>
<span class="linenos">163</span><span class="w">        </span><span class="p">{</span>
<span class="linenos">164</span><span class="w">          </span><span class="nt">&quot;func&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;func1&quot;</span><span class="p">,</span>
<span class="linenos">165</span><span class="w">          </span><span class="nt">&quot;sample&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span>
<span class="linenos">166</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">167</span><span class="w">      </span><span class="p">],</span>
<span class="linenos">168</span><span class="w">      </span><span class="nt">&quot;rules&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="linenos">169</span><span class="w">        </span><span class="s2">&quot;SLList_init&quot;</span><span class="p">,</span>
<span class="linenos">170</span><span class="w">        </span><span class="s2">&quot;SLList_insert&quot;</span><span class="p">,</span>
<span class="linenos">171</span><span class="w">        </span><span class="s2">&quot;SLList_search&quot;</span><span class="p">,</span>
<span class="linenos">172</span><span class="w">        </span><span class="s2">&quot;SLList_destroy&quot;</span>
<span class="linenos">173</span><span class="w">      </span><span class="p">],</span>
<span class="linenos">174</span><span class="w">      </span><span class="nt">&quot;method&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;custom&quot;</span>
<span class="linenos">175</span><span class="w">    </span><span class="p">},</span>
<span class="linenos">176</span><span class="w">    </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;complexity&quot;</span>
<span class="linenos">177</span><span class="w">  </span><span class="p">},</span>
<span class="linenos">178</span><span class="w">  </span><span class="nt">&quot;resource_type_map&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">179</span><span class="w">    </span><span class="nt">&quot;SLList_insert(SLList*, int)#0&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">180</span><span class="w">      </span><span class="nt">&quot;subtype&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;time delta&quot;</span><span class="p">,</span>
<span class="linenos">181</span><span class="w">      </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;SLList_insert(SLList*, int)&quot;</span><span class="p">,</span>
<span class="linenos">182</span><span class="w">      </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;6.8e-05s&quot;</span><span class="p">,</span>
<span class="linenos">183</span><span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mixed&quot;</span>
<span class="linenos">184</span><span class="w">    </span><span class="p">},</span>
<span class="linenos">185</span><span class="w">    </span><span class="nt">&quot;SLList_destroy(SLList*)#0&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">186</span><span class="w">      </span><span class="nt">&quot;subtype&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;time delta&quot;</span><span class="p">,</span>
<span class="linenos">187</span><span class="w">      </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;SLList_destroy(SLList*)&quot;</span><span class="p">,</span>
<span class="linenos">188</span><span class="w">      </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;6.8e-05s&quot;</span><span class="p">,</span>
<span class="linenos">189</span><span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mixed&quot;</span>
<span class="linenos">190</span><span class="w">    </span><span class="p">},</span>
<span class="linenos">191</span><span class="w">    </span><span class="nt">&quot;SLList_init(SLList*)#0&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">192</span><span class="w">      </span><span class="nt">&quot;subtype&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;time delta&quot;</span><span class="p">,</span>
<span class="linenos">193</span><span class="w">      </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;SLList_init(SLList*)&quot;</span><span class="p">,</span>
<span class="linenos">194</span><span class="w">      </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;6.8e-05s&quot;</span><span class="p">,</span>
<span class="linenos">195</span><span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mixed&quot;</span>
<span class="linenos">196</span><span class="w">    </span><span class="p">},</span>
<span class="linenos">197</span><span class="w">    </span><span class="nt">&quot;SLList_search(SLList*, int)#0&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">198</span><span class="w">      </span><span class="nt">&quot;subtype&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;time delta&quot;</span><span class="p">,</span>
<span class="linenos">199</span><span class="w">      </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;SLList_search(SLList*, int)&quot;</span><span class="p">,</span>
<span class="linenos">200</span><span class="w">      </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;6.8e-05s&quot;</span><span class="p">,</span>
<span class="linenos">201</span><span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mixed&quot;</span>
<span class="linenos">202</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">203</span><span class="w">  </span><span class="p">},</span>
<span class="linenos">204</span><span class="w">  </span><span class="nt">&quot;postprocessors&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span>
<span class="linenos">205</span><span class="w">  </span><span class="nt">&quot;origin&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;f7f3dcea69b97f2b03c421a223a770917149cfae&quot;</span>
<span class="linenos">206</span><span class="p">}</span>
</pre></div>
</div>
<p>The profile above shows the complexity profile taken from <a class="reference internal" href="collectors.html#collectors-trace-examples"><span class="std std-ref">Examples</span></a> and
postprocessed using the full method. The highlighted part shows all of the fully computed models of
form <span class="math notranslate nohighlight">\(y = b_0 + b_1*f(x)\)</span>, represented by their types (e.g. <cite>linear</cite>, <cite>quadratic</cite>, etc.),
concrete found coeficients <span class="math notranslate nohighlight">\(b_0\)</span> and <span class="math notranslate nohighlight">\(b_1\)</span> and e.g. coeficient of determination
<span class="math notranslate nohighlight">\(R^2\)</span> for measuring the fitting of the model.</p>
<img alt="_images/complexity-scatter-with-models-full.png" src="_images/complexity-scatter-with-models-full.png" />
<p>The <a class="reference internal" href="views.html#views-scatter"><span class="std std-ref">Scatter Plot</span></a> above shows the interpreted models of different complexity example,
computed using the <strong>full computation</strong> method. In the picture, one can see that the depedency of
running time based on the structural size is best fitted by <cite>linear</cite> models.</p>
<img alt="_images/complexity-scatter-with-models-initial-guess.png" src="_images/complexity-scatter-with-models-initial-guess.png" />
<p>The next <cite>scatter plot</cite> displays the same data as previous, but regressed using the <cite>initial guess</cite>
strategy. This strategy first does a computation of all models on small sample of data points. Such
computation yields initial estimate of fitness of models (the initial sample is selected by
random). The best fitted model is then chosen and fully computed on the rest of the data points.</p>
<p>The picture shows only one model, namely <cite>linear</cite> which was fully computed to best fit the given
data points. The rest of the models had worse estimation and hence was not computed at all.</p>
</section>
</section>
<section id="module-perun.postprocess.clusterizer">
<span id="clusterizer"></span><span id="postprocessors-clusterizer"></span><h3>Clusterizer<a class="headerlink" href="#module-perun.postprocess.clusterizer" title="Link to this heading">¶</a></h3>
<p>A postprocessor that attempts to classify resources to clusters.</p>
<p>The main usage of this postprocessors is to prepare any kind of profile for further
postprocessing, mainly by <a class="reference internal" href="#postprocessors-regression-analysis"><span class="std std-ref">Regression Analysis</span></a>. The clusterization
is either realized w.r.t the sorted order of the resources or sliding window,
with parametric width and height.</p>
<section id="postprocessors-clusterizer-cli">
<span id="id3"></span><h4>Command Line Interface<a class="headerlink" href="#postprocessors-clusterizer-cli" title="Link to this heading">¶</a></h4>
<section id="perun-postprocessby-clusterizer">
<h5>perun postprocessby clusterizer<a class="headerlink" href="#perun-postprocessby-clusterizer" title="Link to this heading">¶</a></h5>
<p>Clusters each resource to an appropriate cluster in order to be postprocessable
by regression analysis.</p>
<div class="line-block">
<div class="line">* <strong>Limitations</strong>: <cite>none</cite></div>
<div class="line">* <strong>Dependencies</strong>: <cite>none</cite></div>
</div>
<p>Clusterizer tries to find a suitable cluster for each resource in the profile. The clusters
are either computed w.r.t the sort order of the resource amounts, or are computed according
to the sliding window.</p>
<p>The sliding window can be further adjusted by setting its <strong>width</strong> (i.e. how many near values
on the x axis will we fit to a cluster) and its <strong>height</strong> (i.e. how big of an interval of
resource amounts will be consider for one cluster). Both <strong>width</strong> and <strong>height</strong> can be further
augmented. <strong>Width</strong> can either be <cite>absolute</cite>, where we take in maximum the absolute number of
resources, <cite>relative</cite>, where we take in maximum the percentage of number of resources for each
cluster, or <cite>weighted</cite>, where we take the number of resource depending on the frequency of their
occurrences. Similarly, the <strong>height</strong> can either be <cite>absolute</cite>, where we set the interval of
amounts to an absolute size, or <cite>relative</cite>, where we set the interval of amounts relative to the
to the first resource amount in the cluster (so e.g. if we have window of height 0.1 and the
first resource in the cluster has amount of 100, we will cluster every resources in interval 100
to 110 to this cluster).</p>
<p>For more details about regression analysis refer to <a class="reference internal" href="#postprocessors-clusterizer"><span class="std std-ref">Clusterizer</span></a>.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>clusterizer<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span>
</pre></div>
</div>
<p class="rubric">Options</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-clusterizer-s">
<span id="cmdoption-perun-postprocessby-clusterizer-strategy"></span><span class="sig-name descname"><span class="pre">-s</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--strategy</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;strategy&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-clusterizer-s" title="Link to this definition">¶</a></dt>
<dd><p>Specifies the clustering strategy, that will be applied for the profile</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>sort_order | sliding_window</p>
</dd>
</dl>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-clusterizer-wh">
<span id="cmdoption-perun-postprocessby-clusterizer-window-height"></span><span class="sig-name descname"><span class="pre">-wh</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--window-height</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;window_height&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-clusterizer-wh" title="Link to this definition">¶</a></dt>
<dd><p>Specifies the height of the window (either fixed or proportional)</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-clusterizer-rwh">
<span id="cmdoption-perun-postprocessby-clusterizer-relative-window-height"></span><span class="sig-name descname"><span class="pre">-rwh</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--relative-window-height</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-perun-postprocessby-clusterizer-rwh" title="Link to this definition">¶</a></dt>
<dd><p>Specifies that the height of the window is relative to the point</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-clusterizer-fwh">
<span id="cmdoption-perun-postprocessby-clusterizer-fixed-window-height"></span><span class="sig-name descname"><span class="pre">-fwh</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--fixed-window-height</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-perun-postprocessby-clusterizer-fwh" title="Link to this definition">¶</a></dt>
<dd><p>Specifies that the height of the window is absolute to the point</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-clusterizer-ww">
<span id="cmdoption-perun-postprocessby-clusterizer-window-width"></span><span class="sig-name descname"><span class="pre">-ww</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--window-width</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;window_width&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-clusterizer-ww" title="Link to this definition">¶</a></dt>
<dd><p>Specifies the width of the window, i.e. how many values will be taken by window.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-clusterizer-rww">
<span id="cmdoption-perun-postprocessby-clusterizer-relative-window-width"></span><span class="sig-name descname"><span class="pre">-rww</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--relative-window-width</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-perun-postprocessby-clusterizer-rww" title="Link to this definition">¶</a></dt>
<dd><p>Specifies whether the width of the window is weighted or fixed</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-clusterizer-fww">
<span id="cmdoption-perun-postprocessby-clusterizer-fixed-window-width"></span><span class="sig-name descname"><span class="pre">-fww</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--fixed-window-width</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-perun-postprocessby-clusterizer-fww" title="Link to this definition">¶</a></dt>
<dd><p>Specifies whether the width of the window is weighted or fixed</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-clusterizer-www">
<span id="cmdoption-perun-postprocessby-clusterizer-weighted-window-width"></span><span class="sig-name descname"><span class="pre">-www</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--weighted-window-width</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-perun-postprocessby-clusterizer-www" title="Link to this definition">¶</a></dt>
<dd><p>Specifies whether the width of the window is weighted or fixed</p>
</dd></dl>

</section>
</section>
<section id="postprocessors-clusterizer-examples">
<span id="id4"></span><h4>Examples<a class="headerlink" href="#postprocessors-clusterizer-examples" title="Link to this heading">¶</a></h4>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="p">{</span>
<span class="linenos"> 2</span><span class="w">  </span><span class="nt">&quot;snapshots&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="linenos"> 3</span><span class="w">    </span><span class="p">{</span>
<span class="linenos"> 4</span><span class="w">      </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;5.000000&quot;</span><span class="p">,</span>
<span class="linenos"> 5</span><span class="w">      </span><span class="nt">&quot;resources&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="linenos"> 6</span><span class="w">        </span><span class="p">{</span>
<span class="linenos"> 7</span><span class="w">          </span><span class="nt">&quot;amount&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="linenos"> 8</span><span class="w">          </span><span class="nt">&quot;trace&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="linenos"> 9</span><span class="w">            </span><span class="p">{</span>
<span class="linenos">10</span><span class="w">              </span><span class="nt">&quot;line&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="linenos">11</span><span class="w">              </span><span class="nt">&quot;function&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;malloc&quot;</span><span class="p">,</span>
<span class="linenos">12</span><span class="w">              </span><span class="nt">&quot;source&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;unreachable&quot;</span>
<span class="linenos">13</span><span class="w">            </span><span class="p">},</span>
<span class="linenos">14</span><span class="w">            </span><span class="p">{</span>
<span class="linenos">15</span><span class="w">              </span><span class="nt">&quot;line&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span>
<span class="linenos">16</span><span class="w">              </span><span class="nt">&quot;function&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;main&quot;</span><span class="p">,</span>
<span class="linenos">17</span><span class="w">              </span><span class="nt">&quot;source&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;../memory_collect_test.c&quot;</span>
<span class="linenos">18</span><span class="w">            </span><span class="p">},</span>
<span class="linenos">19</span><span class="w">            </span><span class="p">{</span>
<span class="linenos">20</span><span class="w">              </span><span class="nt">&quot;line&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="linenos">21</span><span class="w">              </span><span class="nt">&quot;function&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;__libc_start_main&quot;</span><span class="p">,</span>
<span class="linenos">22</span><span class="w">              </span><span class="nt">&quot;source&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;unreachable&quot;</span>
<span class="linenos">23</span><span class="w">            </span><span class="p">},</span>
<span class="linenos">24</span><span class="w">            </span><span class="p">{</span>
<span class="linenos">25</span><span class="w">              </span><span class="nt">&quot;line&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="linenos">26</span><span class="w">              </span><span class="nt">&quot;function&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;_start&quot;</span><span class="p">,</span>
<span class="linenos">27</span><span class="w">              </span><span class="nt">&quot;source&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;unreachable&quot;</span>
<span class="linenos">28</span><span class="w">            </span><span class="p">}</span>
<span class="linenos">29</span><span class="w">          </span><span class="p">],</span>
<span class="linenos">30</span><span class="w">          </span><span class="nt">&quot;address&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">31584848</span><span class="p">,</span>
<span class="linenos">31</span><span class="w">          </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;../memory_collect_test.c:main#22&quot;</span><span class="p">,</span>
<span class="hll"><span class="linenos">32</span><span class="w">          </span><span class="nt">&quot;cluster&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
</span><span class="linenos">33</span><span class="w">          </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;memory&quot;</span><span class="p">,</span>
<span class="linenos">34</span><span class="w">          </span><span class="nt">&quot;subtype&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;malloc&quot;</span>
<span class="linenos">35</span><span class="w">        </span><span class="p">},</span>
<span class="linenos">36</span><span class="w">      </span><span class="p">]</span>
<span class="linenos">37</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">38</span><span class="w">  </span><span class="p">]</span>
<span class="linenos">39</span><span class="p">}</span>
</pre></div>
</div>
<p>The profile above shows an example of profile postprocessed by clusterizer (note that this is only
an excerpt of the whole profile). Each resource is annotated by a new field named <code class="docutils literal notranslate"><span class="pre">cluster</span></code>,
which can be used in further interpretation of the profiles (either by <a class="reference internal" href="views.html#views-bars"><span class="std std-ref">Bars Plot</span></a>,
<a class="reference internal" href="views.html#views-scatter"><span class="std std-ref">Scatter Plot</span></a> or <a class="reference internal" href="#postprocessors-regression-analysis"><span class="std std-ref">Regression Analysis</span></a>).</p>
<img alt="_images/clusterizer-memory-scatter.png" src="_images/clusterizer-memory-scatter.png" />
<p>The <a class="reference internal" href="views.html#views-scatter"><span class="std std-ref">Scatter Plot</span></a> above shows the memory profile of a simple example, which randomly
allocates memory with linear dependency and was collected by <a class="reference internal" href="collectors.html#collectors-memory"><span class="std std-ref">Memory Collector</span></a>. Since
<a class="reference internal" href="collectors.html#collectors-memory"><span class="std std-ref">Memory Collector</span></a> does not collect any other information, but memory rallocation records.
Such profile cannot be used to infer any models. However the <a class="reference internal" href="views.html#views-scatter"><span class="std std-ref">Scatter Plot</span></a> above was
postprocessed by clusterizer and hence, we can plot the dependency of amount of allocated memory
per each cluster. The <a class="reference internal" href="views.html#views-scatter"><span class="std std-ref">Scatter Plot</span></a> itself ephasize the linear dependency of allocated
memory depending on some unknown parameters (here represented by <cite>cluster</cite>).</p>
<p>We can use <a class="reference internal" href="#postprocessors-regression-analysis"><span class="std std-ref">Regression Analysis</span></a> to prove our assumption, and on the plot below
we can see that the best model for the amount of allocated memory depending on clusters is indeed
<strong>linear</strong>.</p>
<img alt="_images/clusterizer-memory-scatter-with-models.png" src="_images/clusterizer-memory-scatter-with-models.png" />
</section>
</section>
<section id="module-perun.postprocess.regressogram">
<span id="regressogram-method"></span><span id="postprocessors-regressogram"></span><h3>Regressogram method<a class="headerlink" href="#module-perun.postprocess.regressogram" title="Link to this heading">¶</a></h3>
<p>Postprocessing of input profiles using the non-parametric method: regressogram.
This method serves for finding fitting models for trends in the captured
profiling resources using the constant function at the individual parts of
the whole interval.</p>
<section id="postprocessors-regressogram-cli">
<span id="id5"></span><h4>Command Line Interface<a class="headerlink" href="#postprocessors-regressogram-cli" title="Link to this heading">¶</a></h4>
<section id="perun-postprocessby-regressogram">
<h5>perun postprocessby regressogram<a class="headerlink" href="#perun-postprocessby-regressogram" title="Link to this heading">¶</a></h5>
<p>Execution of the interleaving of profiled resources by <strong>regressogram</strong> models.</p>
<div class="line-block">
<div class="line">* <strong>Limitations</strong>: <cite>none</cite></div>
<div class="line">* <strong>Dependencies</strong>: <cite>none</cite></div>
</div>
<p>Regressogram belongs to the simplest non-parametric methods and its properties are
the following:</p>
<blockquote>
<div><p><strong>Regressogram</strong>: can be described such as step function (i.e. constant function
by parts). Regressogram uses the same basic idea as a histogram for density estimate.
This idea is in dividing the set of values of the x-coordinates (<cite>&lt;per_key&gt;</cite>) into
intervals and the estimate of the point in concrete interval takes the mean/median of the
y-coordinates (<cite>&lt;of_resource_key&gt;</cite>), respectively of its value on this sub-interval.
We currently use the <cite>coefficient of determination</cite> (<span class="math notranslate nohighlight">\(R^2\)</span>) to measure the fitness of
regressogram. The fitness of estimation of regressogram model depends primarily on the
number of buckets into which the interval will be divided. The user can choose number of
buckets manually (<cite>&lt;bucket_window&gt;</cite>) or use one of the following methods to estimate the
optimal number of buckets (<cite>&lt;bucket_method&gt;</cite>):</p>
<blockquote>
<div><div class="line-block">
<div class="line">- <strong>sqrt</strong>: square root (of data size) estimator, used for its speed and simplicity</div>
<div class="line">- <strong>rice</strong>: does not take variability into account, only data size and commonly
overestimates</div>
<div class="line">- <strong>scott</strong>: takes into account data variability and data size, less robust estimator</div>
<div class="line">- <strong>stone</strong>: based on leave-one-out cross validation estimate of the integrated
squared error</div>
<div class="line">- <strong>fd</strong>: robust, takes into account data variability and data size, resilient to
outliers</div>
<div class="line">- <strong>sturges</strong>: only accounts for data size, underestimates for large non-gaussian data</div>
<div class="line">- <strong>doane</strong>: generalization of Sturges’ formula, works better with non-gaussian data</div>
<div class="line">- <strong>auto</strong>: max of the Sturges’ and ‘fd’ estimators, provides good all around
performance</div>
</div>
</div></blockquote>
<p>For more details about these methods to estimate the optimal number of buckets or to view
the code of these methods, you can visit <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram_bin_edges.html#numpy.histogram_bucket_edges">SciPy</a>.</p>
</div></blockquote>
<p>For more details about this approach of non-parametric analysis refer to
<a class="reference internal" href="#postprocessors-regressogram"><span class="std std-ref">Regressogram method</span></a>.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>regressogram<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span>
</pre></div>
</div>
<p class="rubric">Options</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-regressogram-bn">
<span id="cmdoption-perun-postprocessby-regressogram-bucket_number"></span><span class="sig-name descname"><span class="pre">-bn</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--bucket_number</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;bucket_number&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-regressogram-bn" title="Link to this definition">¶</a></dt>
<dd><p>Restricts the number of buckets to which will be placed the values of the selected statistics.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-regressogram-bm">
<span id="cmdoption-perun-postprocessby-regressogram-bucket_method"></span><span class="sig-name descname"><span class="pre">-bm</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--bucket_method</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;bucket_method&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-regressogram-bm" title="Link to this definition">¶</a></dt>
<dd><p>Specifies the method to estimate the optimal number of buckets.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>auto | doane | fd | rice | scott | sqrt | sturges</p>
</dd>
</dl>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-regressogram-sf">
<span id="cmdoption-perun-postprocessby-regressogram-statistic_function"></span><span class="sig-name descname"><span class="pre">-sf</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--statistic_function</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;statistic_function&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-regressogram-sf" title="Link to this definition">¶</a></dt>
<dd><p>Will use the &lt;statistic_function&gt; to compute the values for points within each bucket of regressogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>mean | median</p>
</dd>
</dl>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-regressogram-of">
<span id="cmdoption-perun-postprocessby-regressogram-of-key"></span><span class="sig-name descname"><span class="pre">-of</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--of-key</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;of_resource_key&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-regressogram-of" title="Link to this definition">¶</a></dt>
<dd><p>Sets key for which we are finding the model (y-coordinates).</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-regressogram-per">
<span id="cmdoption-perun-postprocessby-regressogram-per-key"></span><span class="sig-name descname"><span class="pre">-per</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--per-key</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;per_resource_key&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-regressogram-per" title="Link to this definition">¶</a></dt>
<dd><p>Sets the key that will be used as a source variable (x-coordinates).</p>
</dd></dl>

</section>
</section>
<section id="postprocessors-regressogram-examples">
<span id="id6"></span><h4>Examples<a class="headerlink" href="#postprocessors-regressogram-examples" title="Link to this heading">¶</a></h4>
<blockquote>
<div><div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;bucket_stats&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="mf">13.0</span><span class="p">,</span>
<span class="w">        </span><span class="mf">25.5</span>
<span class="w">    </span><span class="p">],</span>
<span class="w">    </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;linear::test2&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;bucket_method&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;doane&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;method&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;regressogram&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;r_square&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.7575757575757576</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;x_end&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">9.0</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;statistic_function&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;x_start&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.0</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The example above shows an example of profile post-processed by regressogram method (note that
this is only an excerpt of the whole profile). Each such model of shows the computed values in
the individual buckets, that are represented by <em>bucket_stats</em>. The next value in this example
is <em>statistic_function</em>, which represented the statistic to compute the value in each bucket. Further
contains the name of the method (<em>bucket_method</em>) by which was calculated the optimal number of
buckets, in this case specifically computed with <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram_bin_edges.html#numpy.histogram_bucket_edges">Doanes</a> formula, and <em>coefficient of determination</em>
(<span class="math notranslate nohighlight">\(R^2\)</span>) for measuring the fitting of the model. Each such model can be used in the further
interpretation of the models (either by <a class="reference internal" href="views.html#views-scatter"><span class="std std-ref">Scatter Plot</span></a> or <a class="reference internal" href="degradation.html#degradation-method-aat"><span class="std std-ref">Average Amount Threshold</span></a>).</p>
<img alt="_images/exp_data_regressogram.png" src="_images/exp_data_regressogram.png" />
<p>The <a class="reference internal" href="views.html#views-scatter"><span class="std std-ref">Scatter Plot</span></a> above shows the interpreted model, computed using the <strong>regressogram</strong>
method. In the picture, one can see that the dependency of running time based on the structural
size is best fitted by <cite>exponential</cite> models.</p>
</section>
</section>
<section id="module-perun.postprocess.moving_average">
<span id="moving-average-methods"></span><span id="postprocessors-moving-average"></span><h3>Moving Average Methods<a class="headerlink" href="#module-perun.postprocess.moving_average" title="Link to this heading">¶</a></h3>
<p>Postprocessing of input profiles using the non-parametric method: moving average.
This method serves to analyze data points in the captured profiling resources
by creating a series of averages, eventually medians, of different subsets of
the full data set.</p>
<section id="postprocessors-moving-average-cli">
<span id="id7"></span><h4>Command Line Interface<a class="headerlink" href="#postprocessors-moving-average-cli" title="Link to this heading">¶</a></h4>
<section id="perun-postprocessby-moving-average">
<h5>perun postprocessby moving_average<a class="headerlink" href="#perun-postprocessby-moving-average" title="Link to this heading">¶</a></h5>
<p>Execution of the interleaving of profiled resources by <em>moving average</em> models.</p>
<div class="line-block">
<div class="line">* <strong>Limitations</strong>: <cite>none</cite></div>
<div class="line">* <strong>Dependencies</strong>: <cite>none</cite></div>
</div>
<p>Moving average methods are the natural generalizations of regressogram method. This
method uses the local averages/medians of y-coordinates (<cite>&lt;of_resource_key&gt;</cite>), but
the estimate in the x-point (<cite>&lt;per_key&gt;</cite>) is based on the centered surroundings of
this points, more precisely:</p>
<blockquote>
<div><p><strong>Moving Average</strong>: is a widely used estimator in the technical analysis, that helps
smooth the dataset by filtering out the ‘noise’. Among the basic properties of this
methods belongs the ability to reduce the effect of temporary variations in data, better
improvement of the fitness of data to a line, so called smoothing, to show the data’s
trend more clearly and highlight any value below or above the trend. The most important
task with this type of non-parametric approach is the choice of the <cite>&lt;window-width&gt;</cite>.
If the user does not choose it, we try approximate this value by using the value of
<cite>coefficient of determination</cite> (<span class="math notranslate nohighlight">\(R^2\)</span>). At the begin of the analysis is set the
initial value of window width and then follows the interleaving of the current dataset,
which runs until the value of <cite>coefficient of determination</cite> will not reach the required
level. By this way is guaranteed the desired smoothness of the resulting models. The two
basic and commonly used <cite>&lt;moving-methods&gt;</cite> are the <strong>simple</strong> moving average (<strong>sma</strong>) and
the <em>exponential</em> moving average (<strong>ema</strong>).</p>
</div></blockquote>
<p>For more details about this approach of non-parametric analysis refer
to <a class="reference internal" href="#postprocessors-moving-average"><span class="std std-ref">Moving Average Methods</span></a>.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>moving_average<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span><span class="w"> </span>COMMAND<span class="w"> </span><span class="o">[</span>ARGS<span class="o">]</span>...
</pre></div>
</div>
<p class="rubric">Options</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-moving_average-mp">
<span id="cmdoption-perun-postprocessby-moving_average-min_periods"></span><span class="sig-name descname"><span class="pre">-mp</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--min_periods</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;min_periods&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-moving_average-mp" title="Link to this definition">¶</a></dt>
<dd><p>Provides the minimum number of observations in window required to have a value. If the number of possible observations smaller then result is NaN.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-moving_average-of">
<span id="cmdoption-perun-postprocessby-moving_average-of-key"></span><span class="sig-name descname"><span class="pre">-of</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--of-key</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;of_resource_key&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-moving_average-of" title="Link to this definition">¶</a></dt>
<dd><p>Sets key for which we are finding the model (y-coordinates).</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-moving_average-per">
<span id="cmdoption-perun-postprocessby-moving_average-per-key"></span><span class="sig-name descname"><span class="pre">-per</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--per-key</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;per_resource_key&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-moving_average-per" title="Link to this definition">¶</a></dt>
<dd><p>Sets the key that will be used as a source variable (x-coordinates).</p>
</dd></dl>

<p class="rubric">Commands</p>
<dl class="object">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">ema</span></span></dt>
<dd><p><strong>Exponential Moving Average</strong></p>
</dd></dl>

<dl class="object">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">sma</span></span></dt>
<dd><p><strong>Simple Moving Average</strong></p>
</dd></dl>

<dl class="object">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">smm</span></span></dt>
<dd><p><strong>Simple Moving Median</strong></p>
</dd></dl>

</section>
<section id="perun-postprocessby-moving-average-sma">
<h5>perun postprocessby moving_average sma<a class="headerlink" href="#perun-postprocessby-moving-average-sma" title="Link to this heading">¶</a></h5>
<p><strong>Simple Moving Average</strong></p>
<p>In the most of cases, it is an unweighted Moving Average, this means that the each
x-coordinate in the data set (profiled resources) has equal importance and is weighted
equally. Then the <cite>mean</cite> is computed from the previous <cite>n data</cite> (<cite>&lt;no-center&gt;</cite>), where the
<cite>n</cite> marks <cite>&lt;window-width&gt;</cite>. However, in science and engineering the mean is normally taken
from an equal number of data on either side of a central value (<cite>&lt;center&gt;</cite>). This ensures
that variations in the mean are aligned with the variations in the mean are aligned with
variations in the data rather than being shifted in the x-axis direction. Since the window
at the boundaries of the interval does not contain enough count of points usually, it is
necessary to specify the value of <cite>&lt;min-periods&gt;</cite> to avoid the NaN result. The role of the
weighted function in this approach belongs to <cite>&lt;window-type&gt;</cite>, which represents the suite
of the following window functions for filtering:</p>
<blockquote>
<div><div class="line-block">
<div class="line">- <strong>boxcar</strong>: known as rectangular or Dirichlet window, is equivalent to no window
at all: –</div>
<div class="line">- <strong>triang</strong>: standard triangular window</div>
<div class="line">- <strong>blackman</strong>: formed by using three terms of a summation of cosines, minimal
leakage, close to optimal</div>
<div class="line">- <strong>hamming</strong>: formed by using a raised cosine with non-zero endpoints, minimize the
nearest side lobe</div>
<div class="line">- <strong>bartlett</strong>: similar to triangular, endpoints are at zero, processing of tapering
data sets</div>
<div class="line">- <strong>parzen</strong>: can be regarded as a generalization of k-nearest neighbor techniques</div>
<div class="line">- <strong>bohman</strong>: convolution of two half-duration cosine lobes</div>
<div class="line">- <strong>blackmanharris</strong>: minimum in the sense that its maximum side lobes are minimized
(symmetric 4-term)</div>
<div class="line">- <strong>nuttall</strong>: minimum 4-term Blackman-Harris window according to Nuttall
(so called ‘Nuttall4c’)</div>
<div class="line">- <strong>barthann</strong>: has a main lobe at the origin and asymptotically decaying side lobes
on both sides</div>
<div class="line">- <strong>kaiser</strong>: formed by using a Bessel function, needs beta value
(set to 14 - good starting point)</div>
</div>
<p>For more details about this window functions or for their visual view you can
see <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows">SciPyWindow</a>.</p>
</div></blockquote>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>moving_average<span class="w"> </span>sma<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span>
</pre></div>
</div>
<p class="rubric">Options</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-moving_average-sma-wt">
<span id="cmdoption-perun-postprocessby-moving_average-sma-window_type"></span><span class="sig-name descname"><span class="pre">-wt</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--window_type</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;window_type&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-moving_average-sma-wt" title="Link to this definition">¶</a></dt>
<dd><p>Provides the window type, if not set then all points are evenly weighted. For further information about window types see the notes in the documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>boxcar | triang | blackman | hamming | bartlett | parzen | bohman | blackmanharris | nuttall | barthann</p>
</dd>
</dl>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-moving_average-sma-center">
<span id="cmdoption-perun-postprocessby-moving_average-sma-no-center"></span><span class="sig-name descname"><span class="pre">--center</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--no-center</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-perun-postprocessby-moving_average-sma-center" title="Link to this definition">¶</a></dt>
<dd><p>If set to False, the result is set to the right edge of the window, else is result set to the center of the window</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-moving_average-sma-ww">
<span id="cmdoption-perun-postprocessby-moving_average-sma-window_width"></span><span class="sig-name descname"><span class="pre">-ww</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--window_width</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;window_width&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-moving_average-sma-ww" title="Link to this definition">¶</a></dt>
<dd><p>Size of the moving window. This is a number of observations used for calculating the statistic. Each window will be a fixed size.</p>
</dd></dl>

</section>
<section id="perun-postprocessby-moving-average-smm">
<h5>perun postprocessby moving_average smm<a class="headerlink" href="#perun-postprocessby-moving-average-smm" title="Link to this heading">¶</a></h5>
<p><strong>Simple Moving Median</strong></p>
<p>The second representative of Simple Moving Average methods is the Simple Moving <strong>Median</strong>.
For this method are applicable to the same rules like in the first described method, except
for the option for choosing the window type, which do not make sense in this approach. The
only difference between these two methods are the way of computation the values in the
individual sub-intervals. Simple Moving <strong>Median</strong> is not based on the computation of
average, but as the name suggests, it based on the <strong>median</strong>.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>moving_average<span class="w"> </span>smm<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span>
</pre></div>
</div>
<p class="rubric">Options</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-moving_average-smm-center">
<span id="cmdoption-perun-postprocessby-moving_average-smm-no-center"></span><span class="sig-name descname"><span class="pre">--center</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--no-center</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-perun-postprocessby-moving_average-smm-center" title="Link to this definition">¶</a></dt>
<dd><p>If set to False, the result is set to the right edge of the window, else is result set to the center of the window</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-moving_average-smm-ww">
<span id="cmdoption-perun-postprocessby-moving_average-smm-window_width"></span><span class="sig-name descname"><span class="pre">-ww</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--window_width</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;window_width&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-moving_average-smm-ww" title="Link to this definition">¶</a></dt>
<dd><p>Size of the moving window. This is a number of observations used for calculating the statistic. Each window will be a fixed size.</p>
</dd></dl>

</section>
<section id="perun-postprocessby-moving-average-ema">
<h5>perun postprocessby moving_average ema<a class="headerlink" href="#perun-postprocessby-moving-average-ema" title="Link to this heading">¶</a></h5>
<p><strong>Exponential Moving Average</strong></p>
<p>This method is a type of moving average methods, also know as <strong>Exponential</strong> Weighted
Moving Average, that places a greater weight and significance on the most recent data
points. The weighting for each far x-coordinate decreases exponentially and never reaching
zero. This approach of moving average reacts more significantly to recent changes than a
<em>Simple</em> Moving Average, which applies an equal weight to all observations in the period.
To calculate an EMA must be first computing the <strong>Simple</strong> Moving Average (SMA) over a
particular sub-interval. In the next step must be calculated the multiplier for smoothing
(weighting) the EMA, which depends on the selected formula, the following options are
supported (<cite>&lt;decay&gt;</cite>):</p>
<blockquote>
<div><div class="line-block">
<div class="line">- <strong>com</strong>: specify decay in terms of center of mass:
<span class="math notranslate nohighlight">\({\alpha}\)</span> = 1 / (1 + com), for com &gt;= 0</div>
<div class="line">- <strong>span</strong>: specify decay in terms of span:
<span class="math notranslate nohighlight">\({\alpha}\)</span> = 2 / (span + 1), for span &gt;= 1</div>
<div class="line">- <strong>halflife</strong>: specify decay in terms of half-life,
<span class="math notranslate nohighlight">\({\alpha}\)</span> = 1 - exp(log(0.5) / halflife), for halflife &gt; 0</div>
<div class="line">- <strong>alpha</strong>: specify smoothing factor
<span class="math notranslate nohighlight">\({\alpha}\)</span> directly: 0 &lt; <span class="math notranslate nohighlight">\({\alpha}\)</span> &lt;= 1</div>
</div>
</div></blockquote>
<p>The computed coefficient <span class="math notranslate nohighlight">\({\alpha}\)</span> represents the degree of weighting decrease, a
constant smoothing factor, The higher value of <span class="math notranslate nohighlight">\({\alpha}\)</span> discounts older
observations faster, the small value to the contrary. Finally, to calculate the current
value of EMA is used the relevant formula. It is important do not confuse <strong>Exponential</strong>
Moving Average with <strong>Simple</strong> Moving Average. An <strong>Exponential</strong> Moving Average behaves
quite differently from the second mentioned method, because it is the function of weighting
factor or length of the average.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>moving_average<span class="w"> </span>ema<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span>
</pre></div>
</div>
<p class="rubric">Options</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-moving_average-ema-d">
<span id="cmdoption-perun-postprocessby-moving_average-ema-decay"></span><span class="sig-name descname"><span class="pre">-d</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--decay</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;decay&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-moving_average-ema-d" title="Link to this definition">¶</a></dt>
<dd><p>Exactly one of “com”, “span”, “halflife”, “alpha” can be provided. Allowed values and relationship between the parameters are specified in the documentation (e.g. –decay=com 3).</p>
</dd></dl>

</section>
</section>
<section id="postprocessors-moving-average-examples">
<span id="id8"></span><h4>Examples<a class="headerlink" href="#postprocessors-moving-average-examples" title="Link to this heading">¶</a></h4>
<blockquote>
<div><div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;bucket_stats&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="mf">0.0</span><span class="p">,</span>
<span class="w">      </span><span class="mf">3.0</span><span class="p">,</span>
<span class="w">      </span><span class="mf">24.0</span><span class="p">,</span>
<span class="w">      </span><span class="mf">81.0</span><span class="p">,</span>
<span class="w">      </span><span class="mf">192.0</span><span class="p">,</span>
<span class="w">      </span><span class="mf">375.0</span>
<span class="w">    </span><span class="p">],</span>
<span class="w">    </span><span class="nt">&quot;per_key&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;structure-unit-size&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;pow::test3&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;x_end&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;r_square&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;method&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;moving_average&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;moving_method&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;sma&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;x_start&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;window_width&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The example above shows an example of profile post-processed by moving average postprocessor (note
that this in only an excerpt of the whole profile). Each such model of moving average model shows
the computed values, that are represented by <em>bucket_stats</em>. The important role has value <em>moving_method</em>,
that represents the method, which was used to create this model. In this field may be one from the
following shortcuts <em>SMA</em>, <em>SMM</em>, <em>EMA</em>, which represents above described methods. The value <em>r_square</em>
serves to assess the suitability of the model and represents the <em>coefficient of determination</em>
(<span class="math notranslate nohighlight">\(R^2\)</span>). Another significant value in the context of the information about the moving average
models is the <em>window_width</em>. This value represents the width of the window, that was used at creating
this model. Since each model can be used in the further interpretation (either by <a class="reference internal" href="views.html#views-scatter"><span class="std std-ref">Scatter Plot</span></a>
or <a class="reference internal" href="degradation.html#degradation-method-aat"><span class="std std-ref">Average Amount Threshold</span></a>), another values have auxiliary character and serves for a different
purposes at its interpretation. Additional values that contain the information about postprocess parameters
can be found in the whole profile, specifically in the part about used post-processors.</p>
<img alt="_images/exp_data_ema.png" src="_images/exp_data_ema.png" />
<p>The <a class="reference internal" href="views.html#views-scatter"><span class="std std-ref">Scatter Plot</span></a> above shows the interpreted model, computed using the <strong>exponential moving average</strong>
method, running with default values of parameters. In the picture, one can see that the dependency of running
time based on the structural size is best fitted by <cite>exponential</cite> models.</p>
</section>
</section>
<section id="module-perun.postprocess.kernel_regression">
<span id="kernel-regression-methods"></span><span id="postprocessors-kernel-regression"></span><h3>Kernel Regression Methods<a class="headerlink" href="#module-perun.postprocess.kernel_regression" title="Link to this heading">¶</a></h3>
<p>A postprocessor that executing the kernel regression over the resources.</p>
<p>Postprocessing of inputs profiles using the kernel regression. Postprocessor,
implementing kernel regression offers several computational methods with
different approaches and different strategies to find optimal parameters.</p>
<section id="postprocessors-kernel-regression-cli">
<span id="id9"></span><h4>Command Line Interface<a class="headerlink" href="#postprocessors-kernel-regression-cli" title="Link to this heading">¶</a></h4>
<section id="perun-postprocessby-kernel-regression">
<h5>perun postprocessby kernel-regression<a class="headerlink" href="#perun-postprocessby-kernel-regression" title="Link to this heading">¶</a></h5>
<p>Execution of the interleaving of profiles resources by <em>kernel</em> models.</p>
<div class="line-block">
<div class="line">* <strong>Limitations</strong>: <cite>none</cite></div>
<div class="line">* <strong>Dependencies</strong>: <cite>none</cite></div>
</div>
<p>In statistics, the kernel regression is a non-parametric approach to estimate the
conditional expectation of a random variable. Generally, the main goal of this approach
is to find non-parametric relation between a pair of random variables X &lt;per-key&gt; and
Y &lt;of-key&gt;. Different from parametric techniques (e.g. linear regression), kernel
regression does not assume any underlying distribution (e.g. linear, exponential, etc.)
to estimate the regression function. The main idea of kernel regression is putting the
<strong>kernel</strong>, that have the role of weighted function, to each observation point in the dataset.
Subsequently, the kernel will assign weight to each point in depends on the distance from the
current data point. The kernel basis formula depends only to the <em>bandwidth</em> from the current
(‘local’) data point X to a set of neighboring data points X.</p>
<blockquote>
<div><p><strong>Kernel Selection</strong> does not important from an asymptotic point of view. It is appropriate
to choose the <strong>optimal</strong> kernel since this group of the kernels are continuously on the
whole definition field and then the estimated regression function inherit smoothness of
the kernel. For example, a suitable kernels can be the <strong>epanechnikov</strong> or <strong>normal</strong>
kernel. This postprocessor offers the <strong>kernel selection</strong> in the <strong>kernel-smoothing</strong>
mode, where are available five different types of kernels. For more information about these
kernels or this kernel regression mode you can see
<a class="reference internal" href="#postprocessors-kernel-regression-kernel-smoothing"><span class="std std-ref">perun postprocessby kernel-regression kernel-smoothing</span></a>.</p>
<p><strong>Bandwidth Selection</strong> is the most important factor at each approach of kernel regression,
since this value significantly affects the smoothness of the resulting estimate. In case,
when is choose the inappropriate value, in the most cases can be expected the following two
situations. The <strong>small</strong> bandwidth value reproduce estimated data and vice versa, the
<strong>large</strong> value leads to over-leaving, so to average of the estimated data. Therefore are
used the methods to determine the bandwidth value. One of the most widespread and most
commonly used methods is the <strong>cross-validation</strong> method. This method is based on the
estimate of the regression function in which will be omitted <em>i-th</em> observation. In this
postprocessor is this method available in the <strong>estimator-setting</strong> mode. Another methods
to determine the bandwidth, which are available in the remaining modes of this postprocessor
are <strong>scott</strong> and <strong>silverman</strong> method. More information about these methods and its
definition you cas see in the part <a class="reference internal" href="#postprocessors-kernel-regression-method-selection"><span class="std std-ref">perun postprocessby kernel-regression method-selection</span></a>.</p>
</div></blockquote>
<p>This postprocessor in summary offers five different modes, which does not differ in the
resulting estimate, but in the way of computation the resulting estimate. Better said, it
means, that the result of each mode is the <strong>kernel estimate</strong> with relevant parameters,
selected according to the concrete mode. In short we will describe the individual methods, for
more information about it, you can visit the relevant parts of documentation:</p>
<blockquote>
<div><div class="line-block">
<div class="line">* <strong>Estimator-Settings</strong>: Nadaraya-Watson kernel regression with specific settings
for estimate</div>
<div class="line">* <strong>User-Selection</strong>: Nadaraya-Watson kernel regression with user bandwidth</div>
<div class="line">* <strong>Method-Selection</strong>: Nadaraya-Watson kernel regression with supporting bandwidth
selection method</div>
<div class="line">* <strong>Kernel-Smoothing</strong>: Kernel regression with different types of kernel and
regression methods</div>
<div class="line">* <strong>Kernel-Ridge</strong>: Nadaraya-Watson kernel regression with automatic bandwidth selection</div>
</div>
</div></blockquote>
<p>For more details about this approach of non-parametric analysis refer
to <a class="reference internal" href="#postprocessors-kernel-regression"><span class="std std-ref">Kernel Regression Methods</span></a>.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>kernel-regression<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span><span class="w"> </span>COMMAND<span class="w"> </span><span class="o">[</span>ARGS<span class="o">]</span>...
</pre></div>
</div>
<p class="rubric">Options</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-of">
<span id="cmdoption-perun-postprocessby-kernel-regression-of-key"></span><span class="sig-name descname"><span class="pre">-of</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--of-key</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;of_resource_key&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-of" title="Link to this definition">¶</a></dt>
<dd><p>Sets key for which we are finding the model (y-coordinates).</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-per">
<span id="cmdoption-perun-postprocessby-kernel-regression-per-key"></span><span class="sig-name descname"><span class="pre">-per</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--per-key</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;per_resource_key&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-per" title="Link to this definition">¶</a></dt>
<dd><p>Sets the key that will be used as a source variable (x-coordinates).</p>
</dd></dl>

<p class="rubric">Commands</p>
<dl class="object">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">estimator-settings</span></span></dt>
<dd><p>Nadaraya-Watson kernel regression with…</p>
</dd></dl>

<dl class="object">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">kernel-ridge</span></span></dt>
<dd><p>Nadaraya-Watson kernel regression with…</p>
</dd></dl>

<dl class="object">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">kernel-smoothing</span></span></dt>
<dd><p>Kernel regression with different types of…</p>
</dd></dl>

<dl class="object">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">method-selection</span></span></dt>
<dd><p>Nadaraya-Watson kernel regression with…</p>
</dd></dl>

<dl class="object">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">user-selection</span></span></dt>
<dd><p>Nadaraya-Watson kernel regression with…</p>
</dd></dl>

</section>
<section id="perun-postprocessby-kernel-regression-estimator-settings">
<span id="postprocessors-kernel-regression-estimator-settings"></span><h5>perun postprocessby kernel-regression estimator-settings<a class="headerlink" href="#perun-postprocessby-kernel-regression-estimator-settings" title="Link to this heading">¶</a></h5>
<p>Nadaraya-Watson kernel regression with specific settings for estimate.</p>
<p>As has been mentioned above, the kernel regression aims to estimate the functional relation
between explanatory variable <strong>y</strong> and the response variable <strong>X</strong>. This mode of kernel
regression postprocessor calculates the conditional mean <strong>E[y|X] = m(X)</strong>, where <strong>y = m(X) +</strong>
<span class="math notranslate nohighlight">\(\epsilon\)</span>. Variable <strong>X</strong> is represented in the postprocessor by &lt;per-key&gt; option and
the variable <strong>y</strong> is represented by &lt;of-key&gt; option.</p>
<p><strong>Regression Estimator &lt;reg-type&gt;</strong>:</p>
<blockquote>
<div><blockquote>
<div><p>This mode offer two types of <em>regression estimator</em> &lt;<cite>reg-type</cite>&gt;. <em>Local Constant (`ll`)</em>
type of regression provided by this mode is also known as <em>Nadaraya-Watson</em>
kernel regression:</p>
<blockquote>
<div><p><strong>Nadaraya-Watson</strong>: expects the following conditional expectation: <strong>E[y|X] = m(X)</strong>,
where function <strong>m(*)</strong> represents the regression function to estimate. Then we can
alternatively write the following formula: <strong>y = m(X) +</strong> <span class="math notranslate nohighlight">\(\epsilon\)</span>, <strong>E</strong>
(<span class="math notranslate nohighlight">\(\epsilon\)</span>) <strong>= 0</strong>. Then we can suppose, that we have the set of independent
observations {(<span class="math notranslate nohighlight">\({x_1}\)</span>, <span class="math notranslate nohighlight">\({y_1}\)</span>), …, (<span class="math notranslate nohighlight">\({x_n}\)</span>, <span class="math notranslate nohighlight">\({y_n}\)</span>)} and
the <strong>Nadaraya-Watson</strong> estimator is defined as:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[m_{h}(x) = \sum_{i=1}^{n}K_h(x - x_i)y_i / \sum_{j=1}^{n}K_h(x - x_j)\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\({K_h}\)</span> is a kernel with bandwidth <em>h</em>. The denominator is a weighting term
with sum 1. It easy to see that this kernel regression estimator is just a weighted sum
of the observed responses <span class="math notranslate nohighlight">\({y_i}\)</span>. There are many other kernel estimators that
are various in compare to this presented estimator. However, since all are asymptotic
equivalently, we will not deal with them closer. <strong>Kernel Regression</strong> postprocessor
works in all modes only with <strong>Nadaraya-Watson</strong> estimator.</p>
</div></blockquote>
</div></blockquote>
<p>The second supported <em>regression estimator</em> in this mode of postprocessor is <em>Local Linear
(`lc`)</em>. This type is an extension of that which suffers less from bias issues at the
edge of the support.</p>
<blockquote>
<div><p><strong>Local Linear</strong>: estimator, that offers various advantages compared with other
kernel-type estimators, such as the <em>Nadaraya-Watson</em> estimator. More precisely, it
adapts to both random and fixed designs, and to various design densities such as highly
clustered designs and nearly uniform designs. It turns out that the <em>local linear</em>
smoother repairs the drawbacks of other kernel regression estimators. An regression
estimator <em>m</em> of <em>m</em> is a linear smoother if, for each <em>x</em>, there is a vector
<span class="math notranslate nohighlight">\(l(x) = (l_1(x), ..., l_n(x))^T\)</span> such that:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[m(x) = \sum_{i=1}^{n}l_i(x)Y_i = l(x)^TY\]</div>
<p>where <span class="math notranslate nohighlight">\(Y = (Y_1, ..., Y_n)^T\)</span>. For kernel estimators:</p>
<div class="math notranslate nohighlight">
\[l_i(x) = K(||x - X_i|| / h) / \sum_{j=1}^{n}K(||x - X_j|| / h)\]</div>
<p>where <em>K</em> represents kernel and <em>h</em> its bandwidth.</p>
</div></blockquote>
<p>For a better imagination, there is an interesting fact, that the following estimators
are linear smoothers too: <em>Gaussian process regression</em>, <em>splines</em>.</p>
</div></blockquote>
</div></blockquote>
<p><strong>Bandwidth Method &lt;bandwidth-method&gt;</strong>:</p>
<blockquote>
<div><p>As has been said in the general description of the <em>kernel regression</em>, once of the most
important factors of the resulting estimate is the kernel <strong>bandwidth</strong>. When the
inappropriate value is selected may occur to <em>under-laying</em> or <em>over-laying</em> fo the
resulting kernel estimate. Since the bandwidth of the kernel is a free parameter which
exhibits a strong influence on the resulting estimate postprocessor offers the method for
its selection. Two most popular data-driven methods of bandwidth selection that have
desirable properties are <em>least-squares cross-validation</em> (<cite>cv_ls</cite>) and the <em>AIC-based</em>
method of <em>Hurvich et al. (1998)</em>, which is based on minimizing a modified
<em>Akaike Information Criterion</em> (<cite>aic</cite>):</p>
<blockquote>
<div><p><strong>Cross-Validation Least-Squares</strong>: determination of the optimal kernel bandwidth for
kernel regression is based on minimizing</p>
<div class="math notranslate nohighlight">
\[CV(h) = n^{-1} \sum_{i=1}^{n}(Y_i - g_{-i}(X_i))^2,\]</div>
<p>where <span class="math notranslate nohighlight">\(g_{-i}(X_i)\)</span> is the estimator of <span class="math notranslate nohighlight">\(g(X_i)\)</span> formed by leaving out the
<em>i-th</em> observation when generating the prediction for observation <em>i</em>.</p>
<p><strong>Hurvich et al.’s</strong> (1998) approach is based on the minimization of</p>
<div class="math notranslate nohighlight">
\[AIC_c = ln(\sigma^2) + ((1 + tr(H) / n) / (1 - (tr(H) + 2) / n),\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\sigma^2  = 1 / n \sum_{i=1}^{n}(Y_i - g(X_i))^2 = Y'(I - H)'(I - H)Y / n\]</div>
<p>with <span class="math notranslate nohighlight">\(g(X_i)\)</span> being a non-parametric regression estimator and <em>H</em> being an <em>n x n</em>
matrix of kernel weights with its <em>(i, j)-th</em> element given by
<span class="math notranslate nohighlight">\(H_{ij} = K_h(X_i, X_j) / \sum_{l=1}^{n} K_h(X_i, X_l)\)</span>, where <span class="math notranslate nohighlight">\(K_h(*)\)</span>
is a generalized product kernel.</p>
</div></blockquote>
<p>Both methods for kernel bandwidth selection the <em>least-squared cross-validation</em> and the
<em>AIC</em> have been shown to be asymptotically equivalent.</p>
</div></blockquote>
<p>The remaining options at this mode of kernel regression postprocessor are described within usage
to it and you can see this in the list below. All these options are parameters to
<em>EstimatorSettings</em> (see <a class="reference external" href="https://www.statsmodels.org/dev/generated/statsmodels.nonparametric.kernel_density.EstimatorSettings.html">EstimatorSettings</a>), that optimizing the kernel bandwidth based on the
these specified settings.</p>
<p>In the case of confusion about this approach of kernel regression, you can visit <a class="reference external" href="https://www.statsmodels.org/dev/generated/statsmodels.nonparametric.kernel_regression.KernelReg.html#statsmodels.nonparametric.kernel_regression.KernelReg">StatsModels</a>.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>kernel-regression<span class="w"> </span>estimator-settings<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span>
</pre></div>
</div>
<p class="rubric">Options</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-rt">
<span id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-reg-type"></span><span class="sig-name descname"><span class="pre">-rt</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--reg-type</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;reg_type&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-estimator-settings-rt" title="Link to this definition">¶</a></dt>
<dd><p>Provides the type for regression estimator. Supported types are: “lc”: local-constant (Nadaraya-Watson) and “ll”: local-linear estimator. Default is “ll”. For more information about these types you can visit Perun Documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>ll | lc</p>
</dd>
</dl>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-bw">
<span id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-bandwidth-method"></span><span class="sig-name descname"><span class="pre">-bw</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--bandwidth-method</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;bandwidth_method&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-estimator-settings-bw" title="Link to this definition">¶</a></dt>
<dd><p>Provides the method for bandwidth selection. Supported values are: “cv-ls”: least-squares cross validation and “aic”: AIC Hurvich bandwidth estimation. Default is “cv-ls”. For more information about these methods you can visit Perun Documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>cv_ls | aic</p>
</dd>
</dl>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-efficient">
<span id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-uniformly"></span><span class="sig-name descname"><span class="pre">--efficient</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--uniformly</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-estimator-settings-efficient" title="Link to this definition">¶</a></dt>
<dd><p>If True, is executing the efficient bandwidth estimation - by taking smaller sub-samples and estimating the scaling factor of each sub-sample. It is useful for large samples and/or multiple variables. If False (default), all data is used at the same time.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-randomize">
<span id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-no-randomize"></span><span class="sig-name descname"><span class="pre">--randomize</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--no-randomize</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-estimator-settings-randomize" title="Link to this definition">¶</a></dt>
<dd><p>If True, the bandwidth estimation is performed by taking &lt;n_res&gt; random re-samples of size &lt;n-sub-samples&gt; from the full sample. If set to False (default), is performed by slicing the full sample in sub-samples of &lt;n-sub-samples&gt; size, so that all samples are used once.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-nsub">
<span id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-n-sub-samples"></span><span class="sig-name descname"><span class="pre">-nsub</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--n-sub-samples</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;n_sub_samples&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-estimator-settings-nsub" title="Link to this definition">¶</a></dt>
<dd><p>Size of the sub-samples (default is 50).</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-nres">
<span id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-n-re-samples"></span><span class="sig-name descname"><span class="pre">-nres</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--n-re-samples</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;n_re_samples&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-estimator-settings-nres" title="Link to this definition">¶</a></dt>
<dd><p>The number of random re-samples used to bandwidth estimation. It has effect only if &lt;randomize&gt; is set to True. Default values is 25.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-return-median">
<span id="cmdoption-perun-postprocessby-kernel-regression-estimator-settings-return-mean"></span><span class="sig-name descname"><span class="pre">--return-median</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--return-mean</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-estimator-settings-return-median" title="Link to this definition">¶</a></dt>
<dd><p>If True, the estimator uses the median of all scaling factors for each sub-sample to estimate bandwidth of the full sample. If False (default), the estimator used the mean.</p>
</dd></dl>

</section>
<section id="perun-postprocessby-kernel-regression-user-selection">
<span id="postprocessors-kernel-regression-user-selection"></span><h5>perun postprocessby kernel-regression user-selection<a class="headerlink" href="#perun-postprocessby-kernel-regression-user-selection" title="Link to this heading">¶</a></h5>
<p>Nadaraya-Watson kernel regression with user bandwidth.</p>
<p>This mode of kernel regression postprocessor is very similar to <em>estimator-settings</em> mode. Also
offers two types of <em>regression estimator</em> &lt;reg-type&gt; and that the <em>Nadaraya-Watson</em> estimator,
so known as <em>local-constant</em> (<cite>lc</cite>) and the <em>local-linear</em> estimator (<cite>ll</cite>). Details about these
estimators are available in <a class="reference internal" href="#postprocessors-kernel-regression-estimator-settings"><span class="std std-ref">perun postprocessby kernel-regression estimator-settings</span></a>. In
contrary to this mode, which selected a kernel bandwidth using the <em>EstimatorSettings</em> and
chosen parameters, in this mode the user itself selects a kernel bandwidth &lt;bandwidth-value&gt;.
This value will be used to execute the kernel regression. The value of kernel bandwidth in the
resulting estimate may change occasionally, specifically in the case, when the bandwidth value
is too low to execute the kernel regression. Then will be a bandwidth value approximated to the
closest appropriate value, so that is not decreased the accuracy of the resulting estimate.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>kernel-regression<span class="w"> </span>user-selection<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span>
</pre></div>
</div>
<p class="rubric">Options</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-user-selection-rt">
<span id="cmdoption-perun-postprocessby-kernel-regression-user-selection-reg-type"></span><span class="sig-name descname"><span class="pre">-rt</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--reg-type</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;reg_type&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-user-selection-rt" title="Link to this definition">¶</a></dt>
<dd><p>Provides the type for regression estimator. Supported types are: “lc”: local-constant (Nadaraya-Watson) and “ll”: local-linear estimator. Default is “ll”. For more information about these types you can visit Perun Documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>ll | lc</p>
</dd>
</dl>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-user-selection-bv">
<span id="cmdoption-perun-postprocessby-kernel-regression-user-selection-bandwidth-value"></span><span class="sig-name descname"><span class="pre">-bv</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--bandwidth-value</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;bandwidth_value&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-user-selection-bv" title="Link to this definition">¶</a></dt>
<dd><p><strong>Required</strong> The float value of &lt;bandwidth&gt; defined by user, which will be used at kernel regression.</p>
</dd></dl>

</section>
<section id="perun-postprocessby-kernel-regression-method-selection">
<span id="postprocessors-kernel-regression-method-selection"></span><h5>perun postprocessby kernel-regression method-selection<a class="headerlink" href="#perun-postprocessby-kernel-regression-method-selection" title="Link to this heading">¶</a></h5>
<p>Nadaraya-Watson kernel regression with supporting bandwidth selection method.</p>
<p>The last method from a group of three methods based on a similar principle. <em>Method-selection</em>
mode offers the same type of <em>regression estimators</em> &lt;reg-type&gt; as the first two described
methods. The first supported option is <cite>ll</cite>, which represents the <em>local-linear</em> estimator.
<em>Nadaraya-Watson</em> or <em>local constant</em> estimator represents the second option for &lt;reg-type&gt;
parameter. The more detailed description of these estimators is located in
<a class="reference internal" href="#postprocessors-kernel-regression-estimator-settings"><span class="std std-ref">perun postprocessby kernel-regression estimator-settings</span></a>. The difference between this mode
and the two first modes is in the way of determination of a kernel bandwidth. In this mode are
offered two methods to determine bandwidth. These methods try calculated an optimal bandwidth
from predefined formulas:</p>
<blockquote>
<div><p><strong>Scotts’s Rule</strong> of thumb to determine the smoothing bandwidth for a kernel estimation. It
is very fast compute. This rule was designed for density estimation but is usable for kernel
regression too. Typically produces a larger bandwidth and therefore it is useful for
estimating a gradual trend:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[bw = 1.059 * A * n^{-1/5},\]</div>
<p>where <em>n</em> marks the length of X variable &lt;per-key&gt; and</p>
<div class="math notranslate nohighlight">
\[A = min(\sigma(x), IQR(x) / 1.349),\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma\)</span> marks the <a class="reference external" href="https://en.wikipedia.org/wiki/Standard_deviation">StandardDeviation</a> and IQR marks the <a class="reference external" href="https://en.wikipedia.org/wiki/Interquartile_range">InterquartileRange</a>.</p>
</div></blockquote>
<p><strong>Silverman’s Rule</strong> of thumb to determine the smoothing bandwidth for a kernel estimation.
Belongs to most popular method which uses the <em>rule-of-thumb</em>. Rule is originally designs
for <em>density estimation</em> and therefore uses the normal density as a prior for approximating.
For the necessary estimation of the <span class="math notranslate nohighlight">\(\sigma\)</span> of X &lt;per-key&gt; he proposes a robust
version making use of the <a class="reference external" href="https://en.wikipedia.org/wiki/Interquartile_range">InterquartileRange</a>. If the true density is uni-modal, fairly
symmetric and does not have fat tails, it works fine:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[bw = 0.9 * A * n^{-1/5},\]</div>
<p>where <em>n</em> marks the length of X variable &lt;per-key&gt; and</p>
<div class="math notranslate nohighlight">
\[A = min(\sigma(x), IQR(x) / 1.349),\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma\)</span> marks the <a class="reference external" href="https://en.wikipedia.org/wiki/Standard_deviation">StandardDeviation</a> and IQR marks the <a class="reference external" href="https://en.wikipedia.org/wiki/Interquartile_range">InterquartileRange</a>.</p>
</div></blockquote>
</div></blockquote>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>kernel-regression<span class="w"> </span>method-selection<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span>
</pre></div>
</div>
<p class="rubric">Options</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-method-selection-rt">
<span id="cmdoption-perun-postprocessby-kernel-regression-method-selection-reg-type"></span><span class="sig-name descname"><span class="pre">-rt</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--reg-type</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;reg_type&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-method-selection-rt" title="Link to this definition">¶</a></dt>
<dd><p>Provides the type for regression estimator. Supported types are: “lc”: local-constant (Nadaraya-Watson) and “ll”: local-linear estimator. Default is “ll”. For more information about these types you can visit Perun Documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>ll | lc</p>
</dd>
</dl>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-method-selection-bm">
<span id="cmdoption-perun-postprocessby-kernel-regression-method-selection-bandwidth-method"></span><span class="sig-name descname"><span class="pre">-bm</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--bandwidth-method</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;bandwidth_method&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-method-selection-bm" title="Link to this definition">¶</a></dt>
<dd><p>Provides the helper method to determine the kernel bandwidth. The &lt;method_name&gt; will be used to compute the bandwidth, which will be used at kernel regression.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>scott | silverman</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="perun-postprocessby-kernel-regression-kernel-smoothing">
<span id="postprocessors-kernel-regression-kernel-smoothing"></span><h5>perun postprocessby kernel-regression kernel-smoothing<a class="headerlink" href="#perun-postprocessby-kernel-regression-kernel-smoothing" title="Link to this heading">¶</a></h5>
<p>Kernel regression with different types of kernel and regression methods.</p>
<p>This mode of kernel regression postprocessor implements non-parametric regression using
different kernel methods and different kernel types. The calculation in this mode can be split
into three parts. The first part is represented by the <em>kernel type</em>, the second part by
<em>bandwidth computation</em> and the last part is represented by <em>regression method</em>, which will be
used to interleave the given resources. We will look gradually at individual supported options
in the each part of computation.</p>
<blockquote>
<div><p><strong>Kernel Type &lt;kernel-type&gt;</strong>:</p>
<p>In non-parametric statistics a <em>kernel</em> is a weighting function used in estimation
techniques. In <em>kernel regression</em> is used to estimate the conditional expectation of a
random variable. As has been said, <em>kernel width</em> must be specified when running a
non-parametric estimation. The <em>kernel</em> in view of mathematical definition is a
non-negative real-valued integrable function <em>K</em>. For most applications, it is desirable
to define the function to satisfy two additional requirements:</p>
<blockquote>
<div><p><strong>Normalization</strong>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\int_{-\infty}^{+\infty}K(u)du = 1,\]</div>
</div></blockquote>
<p><strong>Symmetry</strong></p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[K(-u) = K(u),\]</div>
</div></blockquote>
<p>for all values of u. The second requirement ensures that the average of the
corresponding distribution is equal to that of the sample used. If <em>K</em> is a kernel,
then so is the function <span class="math notranslate nohighlight">\(K^*\)</span> defined by <span class="math notranslate nohighlight">\(K^*(u) = \lambda K (\lambda u)\)</span>,
where <span class="math notranslate nohighlight">\(\lambda &gt; 0\)</span>. This can be used to select a scale that is appropriate for
the data. This mode offers several types of kernel functions:</p>
</div></blockquote>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Kernel Name</strong></p></td>
<td><p><strong>Kernel Function, K(u)</strong></p></td>
<td><p><strong>Efficiency</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>Gaussian (normal)</strong></p></td>
<td><p><span class="math notranslate nohighlight">\(K(u)=(1/\sqrt{2\pi})e^{-(1/2)u^2}\)</span></p></td>
<td><p>95.1%</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Epanechnikov</strong></p></td>
<td><p><span class="math notranslate nohighlight">\(K(u)=3/4(1-u^2)\)</span></p></td>
<td><p>100%</p></td>
</tr>
<tr class="row-even"><td><p><strong>Tricube</strong></p></td>
<td><p><span class="math notranslate nohighlight">\(K(u)=70/81(1-|u^3|)^3\)</span></p></td>
<td><p>99.8%</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Gaussian order4</strong></p></td>
<td><p><span class="math notranslate nohighlight">\(\phi_4(u)=1/2(3-u^2)\phi(u)\)</span>,
where <span class="math notranslate nohighlight">\(\phi\)</span> is the normal kernel</p></td>
<td><p>not applicable</p></td>
</tr>
<tr class="row-even"><td><p><strong>Epanechnikov order4</strong></p></td>
<td><p><span class="math notranslate nohighlight">\(K_4(u)=-(15/8)u^2+(9/8)\)</span>, where <em>K</em>
is the non-normalized Epanechnikov kernel</p></td>
<td><p>not applicable</p></td>
</tr>
</tbody>
</table>
<p>Efficiency is defined as <span class="math notranslate nohighlight">\(\sqrt{\int{}{}u^2K(u)du}\int{}{}K(u)^2du\)</span>, and
its measured to the <em>Epanechnikov</em> kernel.</p>
<p><strong>Smoothing Method &lt;smoothing-method&gt;</strong>:</p>
<p><em>Kernel-Smoothing</em> mode of this postprocessor offers three different non-parametric
regression methods to execute <em>kernel regression</em>. The first of them is called
<em>spatial-average</em> and perform a <em>Nadaraya-Watson</em> regression (i.e. also called
local-constant regression) on the data using a given kernel:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[m_{h}(x) = \sum_{i=1}^{n}K_h((x-x_i)/h)y_i/\sum_{j=1}^{n}K_h((x-x_j) / h),\]</div>
</div></blockquote>
<p>where <em>K(x)</em> is the kernel and must be such that <em>E(K(x)) = 0</em> and <em>h</em> is the bandwidth of
the method. <em>Local-Constant</em> regression was also described in
<a class="reference internal" href="#postprocessors-kernel-regression-estimator-settings"><span class="std std-ref">perun postprocessby kernel-regression estimator-settings</span></a>. The second supported regression
method by this mode is called <em>local-linear</em>. Compared with previous method, which offers
computational with different types of kernel, this method has restrictions and perform
<em>local-linear</em> regression using only <em>Gaussian (Normal)</em> kernel. The <em>local-constant</em>
regression was described in <a class="reference internal" href="#postprocessors-kernel-regression-estimator-settings"><span class="std std-ref">perun postprocessby kernel-regression estimator-settings</span></a> and
therefore will not be given no further attention to it. <em>Local Polynomial</em> regression is
the last method in this mode and perform regression in <em>N-D</em> using a user-provided kernel.
The <em>local-polynomial</em> regression is the function that minimizes, for each position:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[m_{h}(x) = \sum_{i=0}^{n}K((x - x_i) / h)(y_i - a_0 - P_q(x_i -x))^2,\]</div>
</div></blockquote>
<p>where <em>K(x)</em> is the kernel such that <em>E(K(x)) = 0</em>, <em>q</em> is the order of the fitted
polynomial &lt;polynomial-order&gt;, <span class="math notranslate nohighlight">\(P_q(x)\)</span> is a polynomial or order <em>q</em> in <em>x</em>, and <em>h</em>
is the bandwidth of the method. The polynomial <span class="math notranslate nohighlight">\(P_q(x)\)</span> is of the form:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[F_d(k) = { n \in N^d | \sum_{i=1}^{d}n_i = k }\]</div>
<div class="math notranslate nohighlight">
\[P_q(x_1, ..., x_d) = \sum_{k=1}^{q}{}\sum_{n \in F_d(k)}^{}{}
        a_{k,n}\prod_{i=1}^{d}x_{i}^{n_i}\]</div>
</div></blockquote>
<p>For example we can have:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[P_2(x, y) = a_{110}x + a_{101}y + a_{220}x^2 + a_{221}xy + a_{202}y^2\]</div>
</div></blockquote>
</div></blockquote>
<p>The last part of the calculation is the <em>bandwidth</em> computation. This mode offers to user enter
the value directly with use of parameter &lt;bandwidth-value&gt;. The parameter &lt;bandwidth-method&gt;
offers to user the selection from the two methods to determine the optimal bandwidth value.
The supported methods are <em>Scotts’s Rule</em> and <em>Silverman’s Rule</em>, which are described in
<a class="reference internal" href="#postprocessors-kernel-regression-method-selection"><span class="std std-ref">perun postprocessby kernel-regression method-selection</span></a>. This parameter cannot be entered in
combination with &lt;bandwidth-value&gt;, then will be ignored and will be accepted value from
&lt;bandwidth-value&gt;.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>kernel-regression<span class="w"> </span>kernel-smoothing<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span>
</pre></div>
</div>
<p class="rubric">Options</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-kt">
<span id="cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-kernel-type"></span><span class="sig-name descname"><span class="pre">-kt</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--kernel-type</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;kernel_type&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-kt" title="Link to this definition">¶</a></dt>
<dd><p>Provides the set of kernels to execute the <cite>kernel-smoothing</cite> with kernel selected by the user. For exact definitions of these kernels and more information about it, you can visit the Perun Documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>epanechnikov | tricube | normal | epanechnikov4 | normal4</p>
</dd>
</dl>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-sm">
<span id="cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-smoothing-method"></span><span class="sig-name descname"><span class="pre">-sm</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--smoothing-method</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;smoothing_method&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-sm" title="Link to this definition">¶</a></dt>
<dd><p>Provides kernel smoothing methods to executing non-parametric regressions: <cite>local-polynomial</cite> perform a local-polynomial regression in N-D using a user-provided kernel; <cite>local-linear</cite> perform a local-linear regression using a gaussian (normal) kernel; and <cite>spatial-average</cite> perform a Nadaraya-Watson regression on the data (so called local-constant regression) using a user-provided kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>spatial-average | local-linear | local-polynomial</p>
</dd>
</dl>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-bm">
<span id="cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-bandwidth-method"></span><span class="sig-name descname"><span class="pre">-bm</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--bandwidth-method</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;bandwidth_method&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-bm" title="Link to this definition">¶</a></dt>
<dd><p>Provides the helper method to determine the kernel bandwidth. The &lt;bandwidth_method&gt; will be used to compute the bandwidth, which will be used at kernel-smoothing regression. Cannot be entered in combination with &lt;bandwidth-value&gt;, then will be ignored and will be accepted value from &lt;bandwidth-value&gt;.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p>scott | silverman</p>
</dd>
</dl>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-bv">
<span id="cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-bandwidth-value"></span><span class="sig-name descname"><span class="pre">-bv</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--bandwidth-value</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;bandwidth_value&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-bv" title="Link to this definition">¶</a></dt>
<dd><p>The float value of &lt;bandwidth&gt; defined by user, which will be used at kernel regression. If is entered in the combination with &lt;bandwidth-method&gt;, then method will be ignored.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-q">
<span id="cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-polynomial-order"></span><span class="sig-name descname"><span class="pre">-q</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--polynomial-order</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;polynomial_order&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-kernel-smoothing-q" title="Link to this definition">¶</a></dt>
<dd><p>Provides order of the polynomial to fit. Default value of the order is equal to 3. Is accepted only by <cite>local-polynomial</cite> &lt;smoothing-method&gt;, another methods ignoring it.</p>
</dd></dl>

</section>
<section id="perun-postprocessby-kernel-regression-kernel-ridge">
<span id="postprocessors-kernel-regression-kernel-ridge"></span><h5>perun postprocessby kernel-regression kernel-ridge<a class="headerlink" href="#perun-postprocessby-kernel-regression-kernel-ridge" title="Link to this heading">¶</a></h5>
<p>Nadaraya-Watson kernel regression with automatic bandwidth selection.</p>
<p>This mode implements <em>Nadaraya-Watson</em> kernel regression, which was described above in
<a class="reference internal" href="#postprocessors-kernel-regression-estimator-settings"><span class="std std-ref">perun postprocessby kernel-regression estimator-settings</span></a>. While the previous modes provided
the methods to determine the optimal bandwidth with different ways, this method provides a
little bit different way. From a given range of potential bandwidths &lt;gamma-range&gt; try to
select the optimal kernel bandwidth with use of <em>leave-one-out cross-validation</em>. This approach
was described in <a class="reference internal" href="#postprocessors-kernel-regression-estimator-settings"><span class="std std-ref">perun postprocessby kernel-regression estimator-settings</span></a>, where was
introduced the <em>least-squares cross- validation</em> and it is a modification of this approach.
<em>Leave-one-out cross validation</em> is <a class="reference external" href="https://medium.com/datadriveninvestor/k-fold-cross-validation-6b8518070833">K-fold</a> cross validation taken to its logical extreme, with
<em>K</em> equal to <em>N</em>, the number of data points in the set. The original <em>gamma-range</em> will be
divided on the base of size the given step &lt;gamma-step&gt;. The selection of specific value from
this range will be executing by minimizing <a class="reference external" href="https://en.wikipedia.org/wiki/Mean_squared_error">mean-squared-error</a> in
<em>leave-one-out cross-validation</em>. The selected <em>bandwidth-value</em> will serves for <em>gaussian</em>
kernel in resulting estimate: <span class="math notranslate nohighlight">\(K(x, y) = exp(-gamma * ||x-y||^2)\)</span>.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>perun<span class="w"> </span>postprocessby<span class="w"> </span>kernel-regression<span class="w"> </span>kernel-ridge<span class="w"> </span><span class="o">[</span>OPTIONS<span class="o">]</span>
</pre></div>
</div>
<p class="rubric">Options</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-kernel-ridge-gr">
<span id="cmdoption-perun-postprocessby-kernel-regression-kernel-ridge-gamma-range"></span><span class="sig-name descname"><span class="pre">-gr</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--gamma-range</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;gamma_range&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-kernel-ridge-gr" title="Link to this definition">¶</a></dt>
<dd><p>Provides the range for automatic bandwidth selection of the kernel via leave-one-out cross-validation. One value from these range will be selected with minimizing the mean-squared error of leave-one-out cross-validation. The first value will be taken as the lower bound of the range and cannot be greater than the second value.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-perun-postprocessby-kernel-regression-kernel-ridge-gs">
<span id="cmdoption-perun-postprocessby-kernel-regression-kernel-ridge-gamma-step"></span><span class="sig-name descname"><span class="pre">-gs</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--gamma-step</span></span><span class="sig-prename descclassname"> <span class="pre">&lt;gamma_step&gt;</span></span><a class="headerlink" href="#cmdoption-perun-postprocessby-kernel-regression-kernel-ridge-gs" title="Link to this definition">¶</a></dt>
<dd><p>Provides the size of the step, with which will be executed the iteration over the given &lt;gamma-range&gt;. Cannot be greater than length of &lt;gamma-range&gt;, else will be set to value of the lower bound of the &lt;gamma_range&gt;.</p>
</dd></dl>

</section>
</section>
<section id="postprocessors-kernel-regression-examples">
<span id="id12"></span><h4>Examples<a class="headerlink" href="#postprocessors-kernel-regression-examples" title="Link to this heading">¶</a></h4>
<blockquote>
<div><div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;per_key&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;structure-unit-size&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;uid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;quad::test1&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;kernel_mode&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;estimator&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;r_square&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">0.9990518378010778</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;method&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;kernel_regression&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;x_start&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;bandwidth&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">2.672754640321602</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;x_end&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;kernel_stats&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">          </span><span class="mf">115.6085941489687</span><span class="p">,</span>
<span class="w">          </span><span class="mf">155.95838478107163</span><span class="p">,</span>
<span class="w">          </span><span class="mf">190.27598428091824</span><span class="p">,</span>
<span class="w">          </span><span class="mf">219.36576520977312</span><span class="p">,</span>
<span class="w">          </span><span class="mf">252.80699243117965</span><span class="p">,</span>
<span class="w">          </span><span class="mf">268.4600214673941</span><span class="p">,</span>
<span class="w">          </span><span class="mf">283.3744716372719</span><span class="p">,</span>
<span class="w">          </span><span class="mf">282.7535719770607</span><span class="p">,</span>
<span class="w">          </span><span class="mf">276.27153279181573</span><span class="p">,</span>
<span class="w">          </span><span class="mf">269.69580474542016</span><span class="p">,</span>
<span class="w">          </span><span class="mf">244.451017529157</span><span class="p">,</span>
<span class="w">          </span><span class="mf">226.98819185034756</span><span class="p">,</span>
<span class="w">          </span><span class="mf">180.72465187812492</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The example above shows an example of profile post-processed by <em>kernel regression</em> (note that this
is only an excerpt of the whole profile). Each such kernel model shows the values of resulting kernel
estimate, that are part of <em>kernel_stats</em> list. Another fascinating value is stored in <em>kernel_mode</em>
field and means the relevant mode, which executing the <em>kernel regression</em> over this model. In this
field may be one from the following words, which represents the individual modes of kernel regression
postprocessor. The value <em>r_square</em> serves to assess the suitability of the kernel model and represents
the <em>coefficient of determination</em> (<span class="math notranslate nohighlight">\(R^2\)</span>). In the context of another kernel estimates for decreasing
or increasing the resulting accuracy is important the field <em>bandwidth</em>, which represents the kernel
bandwidth in the current kernel model. Since each model can be used in the further interpretation
(either by <a class="reference internal" href="views.html#views-scatter"><span class="std std-ref">Scatter Plot</span></a> or <a class="reference internal" href="degradation.html#degradation-method-aat"><span class="std std-ref">Average Amount Threshold</span></a>), another values have auxiliary character
and serves for a different purposes at its interpretation. Additional values that contain the information
about selected parameters at kernel regression postprocessor and its modes, can be found in the whole profile,
specifically in the part about used post-processors.</p>
<img alt="_images/example_kernel.png" src="_images/example_kernel.png" />
<p>The <a class="reference internal" href="views.html#views-scatter"><span class="std std-ref">Scatter Plot</span></a> above shows the interpreted model, computed using the <em>kernel regression</em> postprocessor,
concretely with default value of parameters in <strong>estimator-settings</strong> mode of this postprocessor. In the picture, can
be see that the dependency of running time based on the structural size.</p>
</section>
</section>
</section>
<section id="creating-your-own-postprocessor">
<span id="postprocessors-custom"></span><h2>Creating your own Postprocessor<a class="headerlink" href="#creating-your-own-postprocessor" title="Link to this heading">¶</a></h2>
<p>New postprocessors can be registered within Perun in several steps. Internally they can be
implemented in any programming language and in order to work with perun requires one to three
phases to be specified as given in <a class="reference internal" href="#postprocessors-overview"><span class="std std-ref">Postprocessors Overview</span></a>—<code class="docutils literal notranslate"><span class="pre">before()</span></code>, <code class="docutils literal notranslate"><span class="pre">postprocess()</span></code>
and <code class="docutils literal notranslate"><span class="pre">after()</span></code>. Each new postprocessor requires a interface module <code class="docutils literal notranslate"><span class="pre">run.py</span></code>, which contains the
three function and, moreover, a CLI function for <a class="reference external" href="http://click.pocoo.org/5/">Click</a> framework.</p>
<p>You can register your new postprocessor as follows:</p>
<blockquote>
<div><ol class="arabic">
<li><p>Run <code class="docutils literal notranslate"><span class="pre">perun</span> <span class="pre">utils</span> <span class="pre">create</span> <span class="pre">postprocess</span> <span class="pre">mypostprocessor</span></code> to generate a new modules in
<code class="docutils literal notranslate"><span class="pre">perun/postprocess</span></code> directory with the following structure. The command takes a predefined
templates for new postprocessors and creates <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> and <code class="docutils literal notranslate"><span class="pre">run.py</span></code> according to the
supplied command line arguments (see <a class="reference internal" href="cli.html#cli-utils-ref"><span class="std std-ref">Utility Commands</span></a> for more information about
interface of <code class="docutils literal notranslate"><span class="pre">perun</span> <span class="pre">utils</span> <span class="pre">create</span></code> command):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">perun</span>
<span class="o">|--</span> <span class="o">/</span><span class="n">postprocess</span>
    <span class="o">|--</span> <span class="o">/</span><span class="n">mypostprocessor</span>
        <span class="o">|--</span> <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="o">|--</span> <span class="n">run</span><span class="o">.</span><span class="n">py</span>
    <span class="o">|--</span> <span class="o">/</span><span class="n">normalizer</span>
    <span class="o">|--</span> <span class="o">/</span><span class="n">regression_analysis</span>
    <span class="o">|--</span> <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
</li>
<li><p>First, implement the <code class="docutils literal notranslate"><span class="pre">__init__py</span></code> file, including the module docstring with brief
postprocessor description and definitions of constants that are used for internal
checks which has the following structure:</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="sd">&quot;&quot;&quot;...&quot;&quot;&quot;</span>
<span class="linenos">2</span>
<span class="linenos">3</span><span class="n">SUPPORTED_PROFILES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mixed|memory|time&quot;</span><span class="p">]</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Next, implement the <code class="docutils literal notranslate"><span class="pre">run.py</span></code> module with <code class="docutils literal notranslate"><span class="pre">postprocess()</span></code> fucntion, (and optionally with
<code class="docutils literal notranslate"><span class="pre">before()</span></code> and <code class="docutils literal notranslate"><span class="pre">after()</span></code> functions). The <code class="docutils literal notranslate"><span class="pre">postprocess()</span></code> function should do the actual
postprocessing of the profile. Each function should return the integer status of the phase,
the status message (used in case of error) and dictionary including params passed to
additional phases and ‘profile’ with dictionary w.r.t. <a class="reference internal" href="profile.html#profile-spec"><span class="std std-ref">Specification of Profile Format</span></a>.</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">def</span> <span class="nf">before</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos"> 2</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;(optional)&quot;&quot;&quot;</span>
<span class="linenos"> 3</span>    <span class="k">return</span> <span class="n">STATUS</span><span class="p">,</span> <span class="n">STATUS_MSG</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="k">def</span> <span class="nf">postprocess</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="o">**</span><span class="n">configuration</span><span class="p">):</span>
<span class="linenos"> 7</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;...&quot;&quot;&quot;</span>
<span class="linenos"> 8</span>    <span class="k">return</span> <span class="n">STATUS</span><span class="p">,</span> <span class="n">STATUS_MSG</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="k">def</span> <span class="nf">after</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">12</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;(optional)&quot;&quot;&quot;</span>
<span class="linenos">13</span>    <span class="k">return</span> <span class="n">STATUS</span><span class="p">,</span> <span class="n">STATUS_MSG</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>Additionally, implement the command line interface function in <code class="docutils literal notranslate"><span class="pre">run.py</span></code>, named the same as
your collector. This function will be called from the command line as <code class="docutils literal notranslate"><span class="pre">perun</span> <span class="pre">postprocessby</span>
<span class="pre">mypostprocessor</span></code> and is based on Click_libary.</p></li>
</ol>
<div class="highlight-udiff notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="gd">--- /home/runner/work/perun/perun/docs/_static/templates/postprocess_run.py</span>
<span class="linenos"> 2</span><span class="gi">+++ /home/runner/work/perun/perun/docs/_static/templates/postprocess_run_api.py</span>
<span class="linenos"> 3</span><span class="gu">@@ -1,3 +1,8 @@</span>
<span class="linenos"> 4</span><span class="gi">+import click</span>
<span class="linenos"> 5</span><span class="gi">+</span>
<span class="linenos"> 6</span><span class="gi">+import perun.logic.runner as runner</span>
<span class="linenos"> 7</span><span class="gi">+</span>
<span class="linenos"> 8</span><span class="gi">+</span>
<span class="linenos"> 9</span><span class="w"> </span>def before(**kwargs):
<span class="linenos">10</span><span class="w"> </span>    &quot;&quot;&quot;(optional)&quot;&quot;&quot;
<span class="linenos">11</span><span class="w"> </span>    return STATUS, STATUS_MSG, dict(kwargs)
<span class="linenos">12</span><span class="gu">@@ -11,3 +16,10 @@</span>
<span class="linenos">13</span><span class="w"> </span>def after(**kwargs):
<span class="linenos">14</span><span class="w"> </span>    &quot;&quot;&quot;(optional)&quot;&quot;&quot;
<span class="linenos">15</span><span class="w"> </span>    return STATUS, STATUS_MSG, dict(kwargs)
<span class="linenos">16</span><span class="gi">+</span>
<span class="linenos">17</span><span class="gi">+</span>
<span class="linenos">18</span><span class="gi">+@click.command()</span>
<span class="linenos">19</span><span class="gi">+@pass_profile</span>
<span class="linenos">20</span><span class="gi">+def regression_analysis(profile, **kwargs):</span>
<span class="linenos">21</span><span class="gi">+    &quot;&quot;&quot;...&quot;&quot;&quot;</span>
<span class="linenos">22</span><span class="gi">+    runner.run_postprocessor_on_profile(profile, &quot;mypostprocessor&quot;, kwargs)</span>
</pre></div>
</div>
<ol class="arabic simple" start="5">
<li><p>Finally register your newly created module in <code class="xref py py-func docutils literal notranslate"><span class="pre">get_supported_module_names()</span></code> located in
<code class="docutils literal notranslate"><span class="pre">perun.utils.__init__.py</span></code>:</p></li>
</ol>
<div class="highlight-udiff notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="gd">--- /home/runner/work/perun/perun/docs/_static/templates/supported_module_names.py</span>
<span class="linenos"> 2</span><span class="gi">+++ /home/runner/work/perun/perun/docs/_static/templates/supported_module_names_postprocess.py</span>
<span class="linenos"> 3</span><span class="gu">@@ -7,7 +7,12 @@</span>
<span class="linenos"> 4</span><span class="w"> </span>    return {
<span class="linenos"> 5</span><span class="w"> </span>        &quot;vcs&quot;: [&quot;git&quot;],
<span class="linenos"> 6</span><span class="w"> </span>        &quot;collect&quot;: [&quot;trace&quot;, &quot;memory&quot;, &quot;time&quot;],
<span class="linenos"> 7</span><span class="gd">-        &quot;postprocess&quot;: [&quot;filter&quot;, &quot;normalizer&quot;, &quot;regression-analysis&quot;],</span>
<span class="linenos"> 8</span><span class="gi">+        &quot;postprocess&quot;: [</span>
<span class="linenos"> 9</span><span class="gi">+            &quot;filter&quot;,</span>
<span class="linenos">10</span><span class="gi">+            &quot;normalizer&quot;,</span>
<span class="linenos">11</span><span class="gi">+            &quot;regression-analysis&quot;,</span>
<span class="linenos">12</span><span class="gi">+            &quot;mypostprocessor&quot;,</span>
<span class="linenos">13</span><span class="gi">+        ],</span>
<span class="linenos">14</span><span class="w"> </span>        &quot;view&quot;: [
<span class="linenos">15</span><span class="w"> </span>            &quot;alloclist&quot;,
<span class="linenos">16</span><span class="w"> </span>            &quot;bars&quot;,
</pre></div>
</div>
<ol class="arabic" start="6">
<li><p>Preferably, verify that registering did not break anything in the Perun and if you are not
using the developer installation, then reinstall Perun:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">test</span>
<span class="n">make</span> <span class="n">install</span>
</pre></div>
</div>
</li>
<li><p>At this point you can start using your postprocessor either using <code class="docutils literal notranslate"><span class="pre">perun</span> <span class="pre">postprocessby</span></code> or using the
following to set the job matrix and run the batch collection of profiles:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">perun</span> <span class="n">config</span> <span class="o">--</span><span class="n">edit</span>
<span class="n">perun</span> <span class="n">run</span> <span class="n">matrix</span>
</pre></div>
</div>
</li>
<li><p>If you think your postprocessor could help others, please, consider making <a class="reference external" href="https://github.com/tfiedor/perun/pull/new/develop">Pull Request</a>.</p></li>
</ol>
</div></blockquote>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><p class="logo">
  <a href="index.html">
    <h3>Perun</h3>
  </a>
</p>
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Postprocessors Overview</a><ul>
<li><a class="reference internal" href="#supported-postprocessors">Supported Postprocessors</a><ul>
<li><a class="reference internal" href="#module-perun.postprocess.normalizer">Normalizer Postprocessor</a><ul>
<li><a class="reference internal" href="#command-line-interface">Command Line Interface</a><ul>
<li><a class="reference internal" href="#perun-postprocessby-normalizer">perun postprocessby normalizer</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-perun.postprocess.regression_analysis">Regression Analysis</a><ul>
<li><a class="reference internal" href="#postprocessors-regression-analysis-cli">Command Line Interface</a><ul>
<li><a class="reference internal" href="#perun-postprocessby-regression-analysis">perun postprocessby regression_analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-perun.postprocess.clusterizer">Clusterizer</a><ul>
<li><a class="reference internal" href="#postprocessors-clusterizer-cli">Command Line Interface</a><ul>
<li><a class="reference internal" href="#perun-postprocessby-clusterizer">perun postprocessby clusterizer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#postprocessors-clusterizer-examples">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-perun.postprocess.regressogram">Regressogram method</a><ul>
<li><a class="reference internal" href="#postprocessors-regressogram-cli">Command Line Interface</a><ul>
<li><a class="reference internal" href="#perun-postprocessby-regressogram">perun postprocessby regressogram</a></li>
</ul>
</li>
<li><a class="reference internal" href="#postprocessors-regressogram-examples">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-perun.postprocess.moving_average">Moving Average Methods</a><ul>
<li><a class="reference internal" href="#postprocessors-moving-average-cli">Command Line Interface</a><ul>
<li><a class="reference internal" href="#perun-postprocessby-moving-average">perun postprocessby moving_average</a></li>
<li><a class="reference internal" href="#perun-postprocessby-moving-average-sma">perun postprocessby moving_average sma</a></li>
<li><a class="reference internal" href="#perun-postprocessby-moving-average-smm">perun postprocessby moving_average smm</a></li>
<li><a class="reference internal" href="#perun-postprocessby-moving-average-ema">perun postprocessby moving_average ema</a></li>
</ul>
</li>
<li><a class="reference internal" href="#postprocessors-moving-average-examples">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-perun.postprocess.kernel_regression">Kernel Regression Methods</a><ul>
<li><a class="reference internal" href="#postprocessors-kernel-regression-cli">Command Line Interface</a><ul>
<li><a class="reference internal" href="#perun-postprocessby-kernel-regression">perun postprocessby kernel-regression</a></li>
<li><a class="reference internal" href="#perun-postprocessby-kernel-regression-estimator-settings">perun postprocessby kernel-regression estimator-settings</a></li>
<li><a class="reference internal" href="#perun-postprocessby-kernel-regression-user-selection">perun postprocessby kernel-regression user-selection</a></li>
<li><a class="reference internal" href="#perun-postprocessby-kernel-regression-method-selection">perun postprocessby kernel-regression method-selection</a></li>
<li><a class="reference internal" href="#perun-postprocessby-kernel-regression-kernel-smoothing">perun postprocessby kernel-regression kernel-smoothing</a></li>
<li><a class="reference internal" href="#perun-postprocessby-kernel-regression-kernel-ridge">perun postprocessby kernel-regression kernel-ridge</a></li>
</ul>
</li>
<li><a class="reference internal" href="#postprocessors-kernel-regression-examples">Examples</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#creating-your-own-postprocessor">Creating your own Postprocessor</a></li>
</ul>
</li>
</ul>

  </div><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="collectors.html" title="previous chapter">Collectors Overview</a></li>
      <li>Next: <a href="views.html" title="next chapter">Visualizations Overview</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/postprocessors.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Tomas Fiedor, Jiri Pavela, Simon Stupinsky, et al..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/postprocessors.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>